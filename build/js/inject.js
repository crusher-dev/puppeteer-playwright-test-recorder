!function(n){var t={};function e(I){if(t[I])return t[I].exports;var g=t[I]={i:I,l:!1,exports:{}};return n[I].call(g.exports,g,g.exports,e),g.l=!0,g.exports}e.m=n,e.c=t,e.d=function(n,t,I){e.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:I})},e.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},e.t=function(n,t){if(1&t&&(n=e(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var I=Object.create(null);if(e.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var g in n)e.d(I,g,function(t){return n[t]}.bind(null,g));return I},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},e.p="",e(e.s=14)}([,function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.Chrome = chrome;\nexports.Window = window;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy91dGlscy90eXBlcy50cz85ZDUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEB0cy1pZ25vcmVcbmV4cG9ydCBjb25zdCBDaHJvbWUgPSBjaHJvbWU7XG5leHBvcnQgY29uc3QgV2luZG93ID0gd2luZG93O1xuIl0sIm1hcHBpbmdzIjoiOzs7OztBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.EVENT_CAPTURED = \'EVENT_CAPTURED\';\nexports.START_RECORDING_SESSION = "START_RECORDING_SESSION";\nexports.DELETE_RECORDING_SESSION = "STOP_RECORDING_SESSION";\nexports.SAVE_EVENT = \'SAVE_EVENT\';\nexports.GET_EVENTS = "GET_EVENTS";\nexports.CHECK_SESSION_STATUS = "CHECK_SESSION_STATUS";\nexports.STOP_RECORDING = "STOP_RECORDING";\nexports.GET_CODE = "GET_CODE";\nexports.DEFAULT_VALIDATION_SCRIPT = "function(html, text, element) {\\n    return text.toLowerCase();\\n}";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb25zdGFudHMudHM/ODVlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgRVZFTlRfQ0FQVFVSRUQgPSAnRVZFTlRfQ0FQVFVSRUQnO1xuXG5cbi8vIEFjdGlvbnNcbmV4cG9ydCBjb25zdCBTVEFSVF9SRUNPUkRJTkdfU0VTU0lPTiA9IFwiU1RBUlRfUkVDT1JESU5HX1NFU1NJT05cIjtcbmV4cG9ydCBjb25zdCBERUxFVEVfUkVDT1JESU5HX1NFU1NJT04gPSBcIlNUT1BfUkVDT1JESU5HX1NFU1NJT05cIjtcbmV4cG9ydCBjb25zdCBTQVZFX0VWRU5UID0gJ1NBVkVfRVZFTlQnO1xuZXhwb3J0IGNvbnN0IEdFVF9FVkVOVFMgPSBcIkdFVF9FVkVOVFNcIjtcbmV4cG9ydCBjb25zdCBDSEVDS19TRVNTSU9OX1NUQVRVUyA9IFwiQ0hFQ0tfU0VTU0lPTl9TVEFUVVNcIjtcbmV4cG9ydCBjb25zdCBTVE9QX1JFQ09SRElORyA9IFwiU1RPUF9SRUNPUkRJTkdcIjtcbmV4cG9ydCBjb25zdCBHRVRfQ09ERSA9IFwiR0VUX0NPREVcIjtcblxuXG4vLyBTY3JpcHRzXG5leHBvcnQgY29uc3QgREVGQVVMVF9WQUxJREFUSU9OX1NDUklQVCA9IGBmdW5jdGlvbihodG1sLCB0ZXh0LCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRleHQudG9Mb3dlckNhc2UoKTtcbn1gXG4iXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUlBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n')},function(module,exports,__webpack_require__){eval("/* global __webpack_public_path__ __HOST__ __PORT__ */\n\n/* eslint no-global-assign: 0 camelcase: 0 */\nif (true) {\n  __webpack_require__.p = chrome.extension.getURL('/');\n} else { var path; }//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3dlYnBhY2svY3VzdG9tUHVibGljUGF0aC5qcz9jOGUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGdsb2JhbCBfX3dlYnBhY2tfcHVibGljX3BhdGhfXyBfX0hPU1RfXyBfX1BPUlRfXyAqL1xuLyogZXNsaW50IG5vLWdsb2JhbC1hc3NpZ246IDAgY2FtZWxjYXNlOiAwICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIF9fd2VicGFja19wdWJsaWNfcGF0aF9fID0gY2hyb21lLmV4dGVuc2lvbi5nZXRVUkwoJy8nKTtcbn0gZWxzZSB7XG4gIC8vIEluIGRldmVsb3BtZW50IG1vZGUsXG4gIC8vIHRoZSBpZnJhbWUgb2YgaW5qZWN0cGFnZSBjYW5ub3QgZ2V0IGNvcnJlY3QgcGF0aCxcbiAgLy8gaXQgbmVlZCB0byBnZXQgcGFyZW50IHBhZ2UgcHJvdG9jb2wuXG4gIGNvbnN0IHBhdGggPSBgLy8ke19fSE9TVF9ffToke19fUE9SVF9ffS9qcy9gO1xuICBpZiAobG9jYXRpb24ucHJvdG9jb2wgPT09ICdodHRwczonIHx8IGxvY2F0aW9uLnNlYXJjaC5pbmRleE9mKCdwcm90b2NvbD1odHRwcycpICE9PSAtMSkge1xuICAgIF9fd2VicGFja19wdWJsaWNfcGF0aF9fID0gYGh0dHBzOiR7cGF0aH1gO1xuICB9IGVsc2Uge1xuICAgIF9fd2VicGFja19wdWJsaWNfcGF0aF9fID0gYGh0dHA6JHtwYXRofWA7XG4gIH1cbn1cbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUFBO0FBRUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar types_1 = __webpack_require__(1);\n\nfunction loadScript(name, tabId, cb) {\n  return new Promise(function (resolve, reject) {\n    if (true) {\n      types_1.Chrome.tabs.executeScript(tabId, {\n        file: "/js/" + name + ".js",\n        runAt: \'document_end\'\n      }, function () {\n        resolve(true);\n\n        if (cb) {\n          cb();\n        }\n      });\n    } else {}\n  });\n}\n\nexports.loadScript = loadScript;\n\nfunction loadAssetScript(path, tabId) {\n  return new Promise(function (resolve, reject) {\n    types_1.Chrome.tabschrome.tabs.executeScript(null, {\n      file: "codemirror.js"\n    }, function () {\n      resolve(true);\n    });\n  });\n}\n\nexports.loadAssetScript = loadAssetScript;\n\nfunction getHTMLContentOfTemplate(template, cb) {\n  fetch(types_1.Chrome.runtime.getURL(template + ".html")).then(function (res) {\n    return res.text();\n  }).then(function (res) {\n    if (cb) {\n      cb(res);\n    }\n  });\n}\n\nexports.getHTMLContentOfTemplate = getHTMLContentOfTemplate;\n\nfunction getActiveTabId() {\n  return new Promise(function (resolve, reject) {\n    types_1.Chrome.tabs.query({\n      active: true,\n      currentWindow: true\n    }, function (tabs) {\n      resolve(tabs[0].id);\n    });\n  });\n}\n\nexports.getActiveTabId = getActiveTabId;\n\nfunction sendPostDataWithForm(url, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var form = document.createElement(\'form\');\n  form.method = "post";\n  form.action = url;\n  form.target = "_blank";\n  var optionKeys = Object.keys(options);\n\n  for (var _i = 0, optionKeys_1 = optionKeys; _i < optionKeys_1.length; _i++) {\n    var optionKey = optionKeys_1[_i];\n    var hiddenField = document.createElement(\'input\');\n    hiddenField.type = \'hidden\';\n    hiddenField.name = optionKey;\n    hiddenField.value = options[optionKey];\n    form.appendChild(hiddenField);\n  }\n\n  document.body.appendChild(form);\n  form.submit();\n  form.remove();\n}\n\nexports.sendPostDataWithForm = sendPostDataWithForm;\n\nfunction changeExtensionIcon(icon) {\n  types_1.Chrome.browserAction.setIcon({\n    path: icon\n  });\n}\n\nexports.changeExtensionIcon = changeExtensionIcon;\n\nfunction getSentenceCaseString(str) {\n  return str[0].toUpperCase() + str.slice(1).toLowerCase();\n}\n\nexports.getSentenceCaseString = getSentenceCaseString;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy91dGlscy9oZWxwZXJzLnRzPzI4ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ2hyb21lIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkU2NyaXB0KG5hbWU6IHN0cmluZywgdGFiSWQ6IGFueSwgY2I6IGFueSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBDaHJvbWUudGFicy5leGVjdXRlU2NyaXB0KHRhYklkLCB7IGZpbGU6IGAvanMvJHtuYW1lfS5qc2AsIHJ1bkF0OiAnZG9jdW1lbnRfZW5kJyB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgIGlmKGNiKSB7XG4gICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGRldjogYXN5bmMgZmV0Y2ggYnVuZGxlXG4gICAgICBmZXRjaChgaHR0cDovL2xvY2FsaG9zdDozMDAwL2pzLyR7bmFtZX0uanNgKVxuICAgICAgICAgIC50aGVuKChyZXMpID0+IHJlcy50ZXh0KCkpXG4gICAgICAgICAgLnRoZW4oKGZldGNoUmVzKSA9PiB7XG4gICAgICAgICAgICBDaHJvbWUudGFicy5leGVjdXRlU2NyaXB0KHRhYklkLCB7IGNvZGU6IGZldGNoUmVzLCBydW5BdDogJ2RvY3VtZW50X2VuZCcgfSwgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgICAgaWYoY2IpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbG9hZEFzc2V0U2NyaXB0KHBhdGg6IHN0cmluZywgdGFiSWQ6IGFueSl7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KT0+IHtcbiAgICBDaHJvbWUudGFic2Nocm9tZS50YWJzLmV4ZWN1dGVTY3JpcHQobnVsbCwgeyBmaWxlOiBcImNvZGVtaXJyb3IuanNcIiB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICB9KTtcbn0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0SFRNTENvbnRlbnRPZlRlbXBsYXRlKHRlbXBsYXRlOiBzdHJpbmcsIGNiOmFueSkge1xuICBmZXRjaChDaHJvbWUucnVudGltZS5nZXRVUkwoYCR7dGVtcGxhdGV9Lmh0bWxgKSlcbiAgICAudGhlbigocmVzKSA9PiByZXMudGV4dCgpKVxuICAgIC50aGVuKChyZXMpID0+IHsgaWYoY2IpIHsgY2IocmVzKTt9IH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0aXZlVGFiSWQoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgQ2hyb21lLnRhYnMucXVlcnkoe2FjdGl2ZTogdHJ1ZSwgY3VycmVudFdpbmRvdzogdHJ1ZX0sICh0YWJzOiBhbnkpID0+IHtcbiAgICAgIHJlc29sdmUodGFic1swXS5pZCk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VuZFBvc3REYXRhV2l0aEZvcm0odXJsOiBzdHJpbmcsIG9wdGlvbnM6IGFueSA9IHt9KXtcbiAgY29uc3QgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgZm9ybS5tZXRob2QgPSBcInBvc3RcIjtcbiAgZm9ybS5hY3Rpb24gPSB1cmw7XG4gIGZvcm0udGFyZ2V0ID0gXCJfYmxhbmtcIjtcbiAgY29uc3Qgb3B0aW9uS2V5cyA9IE9iamVjdC5rZXlzKG9wdGlvbnMpO1xuICBmb3IobGV0IG9wdGlvbktleSBvZiBvcHRpb25LZXlzKXtcbiAgICBjb25zdCBoaWRkZW5GaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgaGlkZGVuRmllbGQudHlwZSA9ICdoaWRkZW4nO1xuICAgIGhpZGRlbkZpZWxkLm5hbWUgPSBvcHRpb25LZXk7XG4gICAgaGlkZGVuRmllbGQudmFsdWUgPSBvcHRpb25zW29wdGlvbktleV07XG5cbiAgICBmb3JtLmFwcGVuZENoaWxkKGhpZGRlbkZpZWxkKTtcbiAgfVxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG4gIGZvcm0uc3VibWl0KCk7XG4gIGZvcm0ucmVtb3ZlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VFeHRlbnNpb25JY29uKGljb246IHN0cmluZyl7XG4gICAgQ2hyb21lLmJyb3dzZXJBY3Rpb24uc2V0SWNvbih7cGF0aDppY29ufSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZW50ZW5jZUNhc2VTdHJpbmcoc3RyOiBzdHJpbmcpe1xuICByZXR1cm4gc3RyWzBdLnRvVXBwZXJDYXNlKCkrc3RyLnNsaWNlKDEpLnRvTG93ZXJDYXNlKCk7XG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBWUE7QUFDQTtBQUNBO0FBQ0E7QUF4QkE7QUFDQTtBQXdCQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFPQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUxBO0FBQ0E7QUFLQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQU9BO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkJBO0FBQ0E7QUFtQkE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBSEE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBSEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///4\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nexports.NAVIGATE_URL = \'NAVIGATE_URL\';\nexports.CLICK = "CLICK";\nexports.INPUT = "INPUT";\nexports.HOVER = "HOVER";\nexports.SCROLL_TO_VIEW = "SCROLL_TO_VIEW";\nexports.ASSERT_TEXT = "ASSERT_TEXT";\nexports.EXTRACT_INFO = "EXTRACT_INFO";\nexports.SCREENSHOT = "SCREENSHOT";\nexports.BLACKOUT = "BLACKOUT";\nexports.WAIT = "WAIT";\nexports.PAGE_SCREENSHOT = "PAGE_SCREENSHOT";//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9jb25zdGFudHMvRE9NRXZlbnRzVG9SZWNvcmQudHM/NDE4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgTkFWSUdBVEVfVVJMID0gJ05BVklHQVRFX1VSTCc7XG5leHBvcnQgY29uc3QgQ0xJQ0sgPSBcIkNMSUNLXCI7XG5leHBvcnQgY29uc3QgSU5QVVQgPSBcIklOUFVUXCI7XG5leHBvcnQgY29uc3QgSE9WRVIgPSBcIkhPVkVSXCI7XG5leHBvcnQgY29uc3QgU0NST0xMX1RPX1ZJRVcgPVwiU0NST0xMX1RPX1ZJRVdcIjtcbmV4cG9ydCBjb25zdCBBU1NFUlRfVEVYVD1cIkFTU0VSVF9URVhUXCI7XG5leHBvcnQgY29uc3QgRVhUUkFDVF9JTkZPID0gXCJFWFRSQUNUX0lORk9cIjtcbmV4cG9ydCBjb25zdCBTQ1JFRU5TSE9UID0gXCJTQ1JFRU5TSE9UXCI7XG5leHBvcnQgY29uc3QgQkxBQ0tPVVQgPSBcIkJMQUNLT1VUXCI7XG5leHBvcnQgY29uc3QgV0FJVCA9IFwiV0FJVFwiO1xuZXhwb3J0IGNvbnN0IFBBR0VfU0NSRUVOU0hPVCA9IFwiUEFHRV9TQ1JFRU5TSE9UXCI7XG4iXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///5\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar types_1 = __webpack_require__(1);\n\nvar constants_1 = __webpack_require__(2);\n\nfunction sendMessageToBackground(payload, callback) {\n  if (callback === void 0) {\n    callback = null;\n  }\n\n  types_1.Chrome.runtime.sendMessage(payload, function (response) {\n    if (callback) {\n      callback(response);\n    }\n  });\n}\n\nexports.sendMessageToBackground = sendMessageToBackground;\n\nfunction sendMessageToPage(payload, callback) {\n  if (callback === void 0) {\n    callback = null;\n  }\n\n  types_1.Chrome.tabs.query({\n    active: true,\n    currentWindow: true\n  }, function (tabs) {\n    types_1.Chrome.tabs.sendMessage(tabs[0].id, payload, function (response) {\n      if (callback) {\n        callback(response);\n      }\n    });\n  });\n}\n\nexports.sendMessageToPage = sendMessageToPage;\n\nfunction getEventsList(tabId) {\n  if (tabId === void 0) {\n    tabId = undefined;\n  }\n\n  return new Promise(function (resolve, reject) {\n    sendMessageToBackground({\n      type: constants_1.GET_EVENTS,\n      payload: {\n        tabId: tabId\n      }\n    }, function (events) {\n      if (!events) {\n        reject("Something went wrong!! Failed to get events from background script.");\n      }\n\n      resolve(events);\n    });\n  });\n}\n\nexports.getEventsList = getEventsList;\n\nfunction getSessionStatus(tabId) {\n  return new Promise(function (resolve, reject) {\n    sendMessageToBackground({\n      type: constants_1.CHECK_SESSION_STATUS,\n      payload: {\n        tabId: tabId\n      }\n    }, function (res) {\n      resolve(res && res.isSessionGoingOn);\n    });\n  });\n}\n\nexports.getSessionStatus = getSessionStatus;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy91dGlscy9tZXNzYWdlVXRpbC50cz8yYzFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENocm9tZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHtDSEVDS19TRVNTSU9OX1NUQVRVUywgR0VUX0VWRU5UU30gZnJvbSBcIi4uL2NvbnN0YW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gc2VuZE1lc3NhZ2VUb0JhY2tncm91bmQocGF5bG9hZDogYW55LCBjYWxsYmFjazogYW55ID0gbnVsbCkge1xuICBDaHJvbWUucnVudGltZS5zZW5kTWVzc2FnZShwYXlsb2FkLCAocmVzcG9uc2U6IGFueSkgPT4ge1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZW5kTWVzc2FnZVRvUGFnZShwYXlsb2FkOiBhbnksIGNhbGxiYWNrOiBhbnkgPSBudWxsKSB7XG4gIENocm9tZS50YWJzLnF1ZXJ5KHsgYWN0aXZlOiB0cnVlLCBjdXJyZW50V2luZG93OiB0cnVlIH0sICh0YWJzOiBhbnkpID0+IHtcbiAgICBDaHJvbWUudGFicy5zZW5kTWVzc2FnZSh0YWJzWzBdLmlkLCBwYXlsb2FkLCAocmVzcG9uc2U6IGFueSkgPT4ge1xuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFdmVudHNMaXN0KHRhYklkOiBhbnkgPSB1bmRlZmluZWQpe1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHNlbmRNZXNzYWdlVG9CYWNrZ3JvdW5kKHt0eXBlOiBHRVRfRVZFTlRTLCBwYXlsb2FkOiB7dGFiSWQ6IHRhYklkfX0sIChldmVudHM6IGFueSk9PntcbiAgICAgIGlmKCFldmVudHMpe1xuICAgICAgICByZWplY3QoXCJTb21ldGhpbmcgd2VudCB3cm9uZyEhIEZhaWxlZCB0byBnZXQgZXZlbnRzIGZyb20gYmFja2dyb3VuZCBzY3JpcHQuXCIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShldmVudHMpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNlc3Npb25TdGF0dXModGFiSWQ6IGFueSl7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgc2VuZE1lc3NhZ2VUb0JhY2tncm91bmQoe3R5cGU6IENIRUNLX1NFU1NJT05fU1RBVFVTLCBwYXlsb2FkOiB7dGFiSWQ6IHRhYklkfX0sIChyZXM6IGFueSk9PiB7XG4gICAgICByZXNvbHZlKHJlcyAmJiByZXMuaXNTZXNzaW9uR29pbmdPbik7XG4gICAgfSk7XG4gIH0pO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFPQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFDQTtBQVNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVZBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nfunction loadContentInBody(content) {\n  document.body.insertAdjacentHTML(\'beforeend\', content);\n}\n\nexports.loadContentInBody = loadContentInBody;\n;\n\nfunction removeAllTargetBlankFromLinks() {\n  var links = document.links,\n      i,\n      length;\n\n  for (i = 0, length = links.length; i < length; i++) {\n    links[i].target == \'_blank\' && links[i].removeAttribute(\'target\');\n  }\n}\n\nexports.removeAllTargetBlankFromLinks = removeAllTargetBlankFromLinks;\n\nfunction startSession() {\n  window.sessionStarted = true;\n}\n\nexports.startSession = startSession;\n\nfunction stopSession() {\n  window.sessionStarted = false;\n}\n\nexports.stopSession = stopSession;\n\nfunction isSessionGoingOn() {\n  return !!window.sessionStarted;\n}\n\nexports.isSessionGoingOn = isSessionGoingOn;\n\nfunction loadCSSIfNotAlreadyLoadedForSomeReason(href) {\n  var ss = document.styleSheets;\n\n  for (var i = 0, max = ss.length; i < max; i++) {\n    if (ss[i].href == "/path/to.css") return;\n  }\n\n  var link = document.createElement("link");\n  link.rel = "stylesheet";\n  link.href = href;\n  link.id = "overlay_css";\n  document.getElementsByTagName("head")[0].appendChild(link);\n}\n\nexports.loadCSSIfNotAlreadyLoadedForSomeReason = loadCSSIfNotAlreadyLoadedForSomeReason;\n\nfunction setAttributeForAllChildNodes(parent, attributeKey, attributeValue) {\n  return __spreadArrays(parent.children).map(function (children) {\n    children.setAttribute(attributeKey, attributeValue);\n  });\n}\n\nexports.setAttributeForAllChildNodes = setAttributeForAllChildNodes;\n\nfunction hideAllChildNodes(parent) {\n  return setAttributeForAllChildNodes(parent, "data-gone", "true");\n}\n\nexports.hideAllChildNodes = hideAllChildNodes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy91dGlscy9kb20udHM/MjM0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gbG9hZENvbnRlbnRJbkJvZHkoY29udGVudDogc3RyaW5nKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgZG9jdW1lbnQuYm9keS5pbnNlcnRBZGphY2VudEhUTUwoICdiZWZvcmVlbmQnLCBjb250ZW50ICk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQWxsVGFyZ2V0QmxhbmtGcm9tTGlua3MoKXtcbiAgbGV0IGxpbmtzID0gZG9jdW1lbnQubGlua3MsIGksIGxlbmd0aDtcblxuICBmb3IgKGkgPSAwLCBsZW5ndGggPSBsaW5rcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGxpbmtzW2ldLnRhcmdldCA9PSAnX2JsYW5rJyAmJiBsaW5rc1tpXS5yZW1vdmVBdHRyaWJ1dGUoJ3RhcmdldCcpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFNlc3Npb24oKXtcbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuc2Vzc2lvblN0YXJ0ZWQgPSB0cnVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcFNlc3Npb24oKXtcbiAgLy8gQHRzLWlnbm9yZVxuICB3aW5kb3cuc2Vzc2lvblN0YXJ0ZWQgPSBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2Vzc2lvbkdvaW5nT24oKXtcbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gISF3aW5kb3cuc2Vzc2lvblN0YXJ0ZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2FkQ1NTSWZOb3RBbHJlYWR5TG9hZGVkRm9yU29tZVJlYXNvbiAoaHJlZjogYW55KSB7XG4gIGxldCBzcyA9IGRvY3VtZW50LnN0eWxlU2hlZXRzO1xuICBmb3IgKGxldCBpID0gMCwgbWF4ID0gc3MubGVuZ3RoOyBpIDwgbWF4OyBpKyspIHtcbiAgICBpZiAoc3NbaV0uaHJlZiA9PSBcIi9wYXRoL3RvLmNzc1wiKVxuICAgICAgcmV0dXJuO1xuICB9XG4gIGxldCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG4gIGxpbmsucmVsID0gXCJzdHlsZXNoZWV0XCI7XG4gIGxpbmsuaHJlZiA9IGhyZWY7XG4gIGxpbmsuaWQ9XCJvdmVybGF5X2Nzc1wiO1xuXG4gIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZChsaW5rKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZUZvckFsbENoaWxkTm9kZXMocGFyZW50OiBhbnksIGF0dHJpYnV0ZUtleTogc3RyaW5nLCBhdHRyaWJ1dGVWYWx1ZTogc3RyaW5nKXtcbiAgcmV0dXJuIFsuLi5wYXJlbnQuY2hpbGRyZW5dLm1hcCgoY2hpbGRyZW46IGFueSk9PntcbiAgICBjaGlsZHJlbi5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlS2V5LCBhdHRyaWJ1dGVWYWx1ZSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGlkZUFsbENoaWxkTm9kZXMocGFyZW50OiBhbnkpe1xuICAgIHJldHVybiBzZXRBdHRyaWJ1dGVGb3JBbGxDaGlsZE5vZGVzKHBhcmVudCwgXCJkYXRhLWdvbmVcIiwgXCJ0cnVlXCIpO1xufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBRUE7QUFDQTtBQUNBO0FBSkE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQUNBO0FBT0E7QUFFQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBSUE7QUFFQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBSUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQWJBO0FBQ0E7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFIQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar DOMEventsToRecord_1 = __webpack_require__(5);\n\nvar importPlayWright = "const playwright = require(\'playwright\');\\n\\n";\nvar header = "const browser = await playwright[\\"chrome\\"].launch();\\nconst page = await context.newPage();\\n";\nvar footer = "await browser.close();\\n";\nvar wrappedHeader = "(async () => {\\n  const browser = await playwright[\\"chromium\\"].launch();\\n  const page = await browser.newPage();\\n";\nvar wrappedFooter = "  await browser.close()\\n})()\\n";\nvar extractInfoUsingScriptFunction = "async function extractInfoUsingScript(page, selector, validationScript){\\n    const elHandle = await page.$(selector);\\n    const escapedInnerHTML = (await elHandle.innerHTML())" + \'.toString().replace(/\\\\`/g, "\\\\\\\\`").trim()\' + ";\\n    const escapedInnerText = (await elHandle.innerText())" + \'.replace(/\\\\`/g, "\\\\\\\\`").trim();\' + ";\\n    \\n    " + "const scriptToEvaluate = \\`(\\` + validationScript + \\`)(\\` + \'\\`\' + escapedInnerHTML + \'\\`\' + \\`, \\` + \'\\`\' + \\`${escapedInnerText}\\` + \'\\`\' + \\`, elHandle)\\`" + ";\\n    const output = eval(scriptToEvaluate);\\n    \\n    return output;\\n}\\n\\n";\n\nvar CodeGenerator = function () {\n  function CodeGenerator(options) {\n    this.helperFunctionsToInclude = {};\n  }\n\n  CodeGenerator.prototype.generate = function (events) {\n    var generatedEventsCode = this._handleEvents(events);\n\n    return importPlayWright + this.addHelperFunctionsIfAny() + wrappedHeader + generatedEventsCode + wrappedFooter;\n  };\n\n  CodeGenerator.prototype.addHelperFunctionsIfAny = function () {\n    var helperFunctions = Object.keys(this.helperFunctionsToInclude);\n    var codeToAdd = "";\n\n    for (var _i = 0, helperFunctions_1 = helperFunctions; _i < helperFunctions_1.length; _i++) {\n      var fun = helperFunctions_1[_i];\n\n      if (fun === DOMEventsToRecord_1.EXTRACT_INFO) {\n        codeToAdd += extractInfoUsingScriptFunction;\n      }\n    }\n\n    return codeToAdd;\n  };\n\n  CodeGenerator.prototype._handleEvents = function (events) {\n    var screenShotFileName;\n    var code = \'\\n\';\n\n    for (var i = 0; i < events.length; i++) {\n      var _a = events[i],\n          event_type = _a.event_type,\n          selector = _a.selector,\n          value = _a.value;\n\n      switch (event_type) {\n        case DOMEventsToRecord_1.NAVIGATE_URL:\n          code += "  await page.goto(\'" + value + "\');\\n";\n          break;\n\n        case DOMEventsToRecord_1.CLICK:\n          code += "  await page.click(\'" + selector + "\');\\n";\n          break;\n\n        case DOMEventsToRecord_1.HOVER:\n          code += "  await page.hover(\'" + selector + "\');\\n";\n          break;\n\n        case DOMEventsToRecord_1.SCREENSHOT:\n          screenShotFileName = selector.replace(/[^\\w\\s]/gi, \'\').replace(/ /g, \'_\') + ("_" + i);\n          code += "  const h_" + i + " =  await page.$(\'" + selector + "\');\\n   h_" + i + ".screenshot({path: \'" + screenShotFileName + ".png\'});\\n";\n          break;\n\n        case DOMEventsToRecord_1.PAGE_SCREENSHOT:\n          screenShotFileName = value.replace(/[^\\w\\s]/gi, \'\').replace(/ /g, "_") + ("_" + i);\n          code += "  await page.screenshot({path: \'" + screenShotFileName + ".png\'});\\n";\n          break;\n\n        case DOMEventsToRecord_1.SCROLL_TO_VIEW:\n          code += "  const stv_" + i + " =  await page.$(\'" + selector + "\');\\n  stv_" + i + ".scrollIntoViewIfNeeded();\\n";\n          break;\n\n        case DOMEventsToRecord_1.INPUT:\n          code += "  await page.type(\'" + selector + "\', \'" + value + "\');\\n";\n          break;\n\n        case DOMEventsToRecord_1.EXTRACT_INFO:\n          var variable_name = Object.keys(value)[0];\n          var validation_script = value[variable_name];\n          this.helperFunctionsToInclude[DOMEventsToRecord_1.EXTRACT_INFO] = true;\n          code += "  let " + variable_name + " = await extractInfoUsingScript(page, \'" + selector + "\', " + \'`\' + validation_script + \'`\' + ")\\n";\n          break;\n\n        case DOMEventsToRecord_1.ASSERT_TEXT:\n          this.helperFunctionsToInclude[DOMEventsToRecord_1.ASSERT_TEXT] = true;\n          code += " ";\n\n        default:\n          console.error("Not supported event");\n      }\n    }\n\n    return code;\n  };\n\n  return CodeGenerator;\n}();\n\nexports["default"] = CodeGenerator;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9zY3JpcHRzL2NvZGUtZ2VuZXJhdG9yLnRzPzcwYmIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQHRzLW5vY2hlY2tcblxuaW1wb3J0IHtcbiAgICBBU1NFUlRfVEVYVCxcbiAgICBDTElDSywgRVhUUkFDVF9JTkZPLFxuICAgIEhPVkVSLFxuICAgIElOUFVULFxuICAgIE5BVklHQVRFX1VSTCxcbiAgICBQQUdFX1NDUkVFTlNIT1QsXG4gICAgU0NSRUVOU0hPVCxcbiAgICBTQ1JPTExfVE9fVklFV1xufSBmcm9tIFwiLi4vY29uc3RhbnRzL0RPTUV2ZW50c1RvUmVjb3JkXCI7XG5cbmNvbnN0IGltcG9ydFBsYXlXcmlnaHQgPSBgY29uc3QgcGxheXdyaWdodCA9IHJlcXVpcmUoJ3BsYXl3cmlnaHQnKTtcXG5cXG5gXG5cbmNvbnN0IGhlYWRlciA9IGBjb25zdCBicm93c2VyID0gYXdhaXQgcGxheXdyaWdodFtcImNocm9tZVwiXS5sYXVuY2goKTtcbmNvbnN0IHBhZ2UgPSBhd2FpdCBjb250ZXh0Lm5ld1BhZ2UoKTtcXG5gXG5cbmNvbnN0IGZvb3RlciA9IGBhd2FpdCBicm93c2VyLmNsb3NlKCk7XFxuYFxuXG5jb25zdCB3cmFwcGVkSGVhZGVyID0gYChhc3luYyAoKSA9PiB7XG4gIGNvbnN0IGJyb3dzZXIgPSBhd2FpdCBwbGF5d3JpZ2h0W1wiY2hyb21pdW1cIl0ubGF1bmNoKCk7XG4gIGNvbnN0IHBhZ2UgPSBhd2FpdCBicm93c2VyLm5ld1BhZ2UoKTtcXG5gXG5cbmNvbnN0IHdyYXBwZWRGb290ZXIgPSBgICBhd2FpdCBicm93c2VyLmNsb3NlKClcbn0pKClcXG5gO1xuXG5cbmNvbnN0IGV4dHJhY3RJbmZvVXNpbmdTY3JpcHRGdW5jdGlvbiA9IGBhc3luYyBmdW5jdGlvbiBleHRyYWN0SW5mb1VzaW5nU2NyaXB0KHBhZ2UsIHNlbGVjdG9yLCB2YWxpZGF0aW9uU2NyaXB0KXtcbiAgICBjb25zdCBlbEhhbmRsZSA9IGF3YWl0IHBhZ2UuJChzZWxlY3Rvcik7XG4gICAgY29uc3QgZXNjYXBlZElubmVySFRNTCA9IChhd2FpdCBlbEhhbmRsZS5pbm5lckhUTUwoKSlgICsgJy50b1N0cmluZygpLnJlcGxhY2UoL1xcXFxgL2csIFwiXFxcXFxcXFxgXCIpLnRyaW0oKScgKyBgO1xuICAgIGNvbnN0IGVzY2FwZWRJbm5lclRleHQgPSAoYXdhaXQgZWxIYW5kbGUuaW5uZXJUZXh0KCkpYCArICcucmVwbGFjZSgvXFxcXGAvZywgXCJcXFxcXFxcXGBcIikudHJpbSgpOycgKyBgO1xuICAgIFxuICAgIGArIFwiY29uc3Qgc2NyaXB0VG9FdmFsdWF0ZSA9IFxcYChcXGAgKyB2YWxpZGF0aW9uU2NyaXB0ICsgXFxgKShcXGAgKyAnXFxgJyArIGVzY2FwZWRJbm5lckhUTUwgKyAnXFxgJyArIFxcYCwgXFxgICsgJ1xcYCcgKyBcXGAke2VzY2FwZWRJbm5lclRleHR9XFxgICsgJ1xcYCcgKyBcXGAsIGVsSGFuZGxlKVxcYFwiICsgYDtcbiAgICBjb25zdCBvdXRwdXQgPSBldmFsKHNjcmlwdFRvRXZhbHVhdGUpO1xuICAgIFxuICAgIHJldHVybiBvdXRwdXQ7XG59XFxuXFxuYDtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb2RlR2VuZXJhdG9yIHtcbiAgICBoZWxwZXJGdW5jdGlvbnNUb0luY2x1ZGU6IGFueTtcblxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnM6IGFueSkge1xuICAgICAgICB0aGlzLmhlbHBlckZ1bmN0aW9uc1RvSW5jbHVkZSA9IHt9O1xuICAgIH1cblxuICAgIGdlbmVyYXRlKGV2ZW50cyl7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZEV2ZW50c0NvZGUgPSB0aGlzLl9oYW5kbGVFdmVudHMoZXZlbnRzKTtcbiAgICAgICAgcmV0dXJuIGltcG9ydFBsYXlXcmlnaHQgKyB0aGlzLmFkZEhlbHBlckZ1bmN0aW9uc0lmQW55KCkgKyB3cmFwcGVkSGVhZGVyICsgZ2VuZXJhdGVkRXZlbnRzQ29kZSArIHdyYXBwZWRGb290ZXI7XG4gICAgfVxuXG4gICAgYWRkSGVscGVyRnVuY3Rpb25zSWZBbnkoKXtcbiAgICAgICAgY29uc3QgaGVscGVyRnVuY3Rpb25zID0gT2JqZWN0LmtleXModGhpcy5oZWxwZXJGdW5jdGlvbnNUb0luY2x1ZGUpO1xuICAgICAgICBsZXQgY29kZVRvQWRkID0gXCJcIjtcbiAgICAgICAgZm9yKGxldCBmdW4gb2YgaGVscGVyRnVuY3Rpb25zKXtcbiAgICAgICAgICAgIGlmKGZ1biA9PT0gRVhUUkFDVF9JTkZPKXtcbiAgICAgICAgICAgICAgICBjb2RlVG9BZGQrPSBleHRyYWN0SW5mb1VzaW5nU2NyaXB0RnVuY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGVUb0FkZDtcbiAgICB9XG5cbiAgICBfaGFuZGxlRXZlbnRzKGV2ZW50czogYW55KXtcbiAgICAgICAgbGV0IHNjcmVlblNob3RGaWxlTmFtZTogc3RyaW5nO1xuICAgICAgICBsZXQgY29kZSA9ICdcXG4nO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeyBldmVudF90eXBlLCBzZWxlY3RvciwgdmFsdWUgfSA9IGV2ZW50c1tpXTtcbiAgICAgICAgICAgIHN3aXRjaCAoZXZlbnRfdHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgTkFWSUdBVEVfVVJMOlxuICAgICAgICAgICAgICAgICAgICBjb2RlICs9IGAgIGF3YWl0IHBhZ2UuZ290bygnJHt2YWx1ZX0nKTtcXG5gO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIENMSUNLOlxuICAgICAgICAgICAgICAgICAgICBjb2RlICs9IGAgIGF3YWl0IHBhZ2UuY2xpY2soJyR7c2VsZWN0b3J9Jyk7XFxuYDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBIT1ZFUjpcbiAgICAgICAgICAgICAgICAgICAgY29kZSArPSBgICBhd2FpdCBwYWdlLmhvdmVyKCcke3NlbGVjdG9yfScpO1xcbmA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU0NSRUVOU0hPVDpcbiAgICAgICAgICAgICAgICAgICAgc2NyZWVuU2hvdEZpbGVOYW1lID0gc2VsZWN0b3IucmVwbGFjZSgvW15cXHdcXHNdL2dpLCAnJykucmVwbGFjZSgvIC9nLCAnXycpICsgYF8ke2l9YDtcbiAgICAgICAgICAgICAgICAgICAgY29kZSArPSBgICBjb25zdCBoXyR7aX0gPSAgYXdhaXQgcGFnZS4kKCcke3NlbGVjdG9yfScpO1xcbiAgIGhfJHtpfS5zY3JlZW5zaG90KHtwYXRoOiAnJHtzY3JlZW5TaG90RmlsZU5hbWV9LnBuZyd9KTtcXG5gXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgUEFHRV9TQ1JFRU5TSE9UOlxuICAgICAgICAgICAgICAgICAgICBzY3JlZW5TaG90RmlsZU5hbWUgPSB2YWx1ZS5yZXBsYWNlKC9bXlxcd1xcc10vZ2ksICcnKS5yZXBsYWNlKC8gL2csXCJfXCIpICsgYF8ke2l9YDtcbiAgICAgICAgICAgICAgICAgICAgY29kZSArPSBgICBhd2FpdCBwYWdlLnNjcmVlbnNob3Qoe3BhdGg6ICcke3NjcmVlblNob3RGaWxlTmFtZX0ucG5nJ30pO1xcbmA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgU0NST0xMX1RPX1ZJRVc6XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgKz0gYCAgY29uc3Qgc3R2XyR7aX0gPSAgYXdhaXQgcGFnZS4kKCcke3NlbGVjdG9yfScpO1xcbiAgc3R2XyR7aX0uc2Nyb2xsSW50b1ZpZXdJZk5lZWRlZCgpO1xcbmBcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBJTlBVVDpcbiAgICAgICAgICAgICAgICAgICAgY29kZSArPSBgICBhd2FpdCBwYWdlLnR5cGUoJyR7c2VsZWN0b3J9JywgJyR7dmFsdWV9Jyk7XFxuYDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBFWFRSQUNUX0lORk86XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhcmlhYmxlX25hbWUgPSBPYmplY3Qua2V5cyh2YWx1ZSlbMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25fc2NyaXB0ID0gdmFsdWVbdmFyaWFibGVfbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyRnVuY3Rpb25zVG9JbmNsdWRlW0VYVFJBQ1RfSU5GT10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjb2RlICs9IGAgIGxldCAke3ZhcmlhYmxlX25hbWV9ID0gYXdhaXQgZXh0cmFjdEluZm9Vc2luZ1NjcmlwdChwYWdlLCAnJHtzZWxlY3Rvcn0nLCBgICsgJ2AnICsgdmFsaWRhdGlvbl9zY3JpcHQgKyAnYCcgKyBgKVxcbmA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgQVNTRVJUX1RFWFQ6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGVscGVyRnVuY3Rpb25zVG9JbmNsdWRlW0FTU0VSVF9URVhUXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvZGUgKz0gYCBgO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb3Qgc3VwcG9ydGVkIGV2ZW50XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFFQTtBQUNBO0FBVUE7QUFFQTtBQUdBO0FBRUE7QUFJQTtBQUlBO0FBQ0E7QUFXQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBbENBO0FBcUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///8\n')},,,,,,function(n,t,e){e(3),n.exports=e(15)},function(module,exports,__webpack_require__){"use strict";eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar dom_1 = __webpack_require__(7);\n\nvar helpers_1 = __webpack_require__(4);\n\nvar types_1 = __webpack_require__(1);\n\nvar UIController_1 = __webpack_require__(16);\n\nfunction initContentScript() {\n  if (dom_1.isSessionGoingOn()) {\n    console.log('Already loaded, returning early');\n    return;\n  }\n\n  dom_1.startSession();\n  helpers_1.getHTMLContentOfTemplate('overlay', function (res) {\n    dom_1.loadContentInBody(\"\" + res);\n    dom_1.loadCSSIfNotAlreadyLoadedForSomeReason(types_1.Chrome.runtime.getURL('styles/overlay.css'));\n    new UIController_1[\"default\"]().boot();\n  });\n}\n\ninitContentScript();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvaW5qZWN0LnRzPzhhZmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtpc1Nlc3Npb25Hb2luZ09uLCBsb2FkQ29udGVudEluQm9keSwgbG9hZENTU0lmTm90QWxyZWFkeUxvYWRlZEZvclNvbWVSZWFzb24sIHN0YXJ0U2Vzc2lvbn0gZnJvbSAnLi91dGlscy9kb20nO1xuaW1wb3J0IHtnZXRBY3RpdmVUYWJJZCwgZ2V0SFRNTENvbnRlbnRPZlRlbXBsYXRlLCBsb2FkU2NyaXB0fSBmcm9tICcuL3V0aWxzL2hlbHBlcnMnO1xuaW1wb3J0IHsgQ2hyb21lIH0gZnJvbSAnLi91dGlscy90eXBlcyc7XG5pbXBvcnQgVUlDb250cm9sbGVyIGZyb20gJy4vc2NyaXB0cy9pbmplY3QvVUlDb250cm9sbGVyJztcblxuZnVuY3Rpb24gaW5pdENvbnRlbnRTY3JpcHQoKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKGlzU2Vzc2lvbkdvaW5nT24oKSkge1xuICAgIGNvbnNvbGUubG9nKCdBbHJlYWR5IGxvYWRlZCwgcmV0dXJuaW5nIGVhcmx5Jyk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHN0YXJ0U2Vzc2lvbigpO1xuICAvLyBAdHMtaWdub3JlXG4gIGdldEhUTUxDb250ZW50T2ZUZW1wbGF0ZSgnb3ZlcmxheScsIChyZXMpID0+IHtcbiAgICAgIGxvYWRDb250ZW50SW5Cb2R5KGAke3Jlc31gKTtcblxuICAgICAgbG9hZENTU0lmTm90QWxyZWFkeUxvYWRlZEZvclNvbWVSZWFzb24oQ2hyb21lLnJ1bnRpbWUuZ2V0VVJMKCdzdHlsZXMvb3ZlcmxheS5jc3MnKSk7XG4gICAgICAobmV3IFVJQ29udHJvbGxlcigpKS5ib290KCk7XG4gIH0pO1xufVxuXG5pbml0Q29udGVudFNjcmlwdCgpO1xuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar recordingOverlay_1 = __webpack_require__(17);\n\nvar constants_1 = __webpack_require__(2);\n\nvar types_1 = __webpack_require__(1);\n\nvar messageUtil_1 = __webpack_require__(6);\n\nvar dom_1 = __webpack_require__(7);\n\nvar helpers_1 = __webpack_require__(4);\n\nvar code_generator_1 = __webpack_require__(8);\n\nvar UIControllerExtends = function () {\n  function UIControllerExtends(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.defaultState = {\n      showingOnboardingOverlay: false,\n      sessionGoingOn: false\n    };\n    var showingOnboardingOverlay = options.showingOnboardingOverlay,\n        sessionGoingOn = options.sessionGoingOn;\n    this.state = __assign(__assign({}, this.defaultState), {\n      showingOnboardingOverlay: showingOnboardingOverlay,\n      sessionGoingOn: sessionGoingOn\n    });\n    this.recordingOverlay = new recordingOverlay_1["default"](this, {});\n  }\n\n  UIControllerExtends.prototype.boot = function () {\n    this.registerEvents();\n    this.startRecording();\n  };\n\n  UIControllerExtends.prototype.registerEvents = function () {\n    types_1.Chrome.runtime.onMessage.addListener(this.handleIncomingMessages.bind(this));\n  };\n\n  UIControllerExtends.prototype.handleIncomingMessages = function (request, sender, sendResponse) {\n    var type = request.type;\n\n    switch (type) {\n      case constants_1.STOP_RECORDING:\n        this.stopRecording();\n        break;\n\n      case constants_1.GET_CODE:\n        var events = request.events;\n        helpers_1.sendPostDataWithForm("http://localhost:7000/app/editor", {\n          actions: events\n        });\n        break;\n\n      default:\n        break;\n    }\n\n    sendResponse(true);\n  };\n\n  UIControllerExtends.prototype.startRecording = function () {\n    console.debug("Starting recording actions");\n    var sessionGoingOn = this.state.sessionGoingOn;\n    messageUtil_1.sendMessageToBackground({\n      type: constants_1.START_RECORDING_SESSION\n    }, function (res) {\n      console.log("Sent" + res);\n    });\n\n    if (sessionGoingOn) {\n      console.warn("Can\'t start new recording session until current session has finished");\n      return;\n    }\n\n    this.recordingOverlay.boot();\n  };\n\n  UIControllerExtends.prototype.getCodeForEvents = function () {\n    messageUtil_1.getEventsList().then(function (events) {\n      var _generator = new code_generator_1["default"]({});\n\n      helpers_1.sendPostDataWithForm("http://localhost:7000/app/editor", {\n        actions: events\n      });\n      window.close();\n    });\n  };\n\n  UIControllerExtends.prototype.stopRecording = function () {\n    console.debug("Stopping recording actions");\n    dom_1.stopSession();\n    this.recordingOverlay.shutDown();\n\n    var _overlayCss = document.querySelector("#overlay_css");\n\n    if (_overlayCss) {\n      _overlayCss.remove();\n    }\n\n    window.location.reload();\n  };\n\n  return UIControllerExtends;\n}();\n\nexports["default"] = UIControllerExtends;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9pbmplY3QvVUlDb250cm9sbGVyLnRzPzUwZDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlY29yZGluZ092ZXJsYXkgZnJvbSBcIi4vdWkvcmVjb3JkaW5nT3ZlcmxheVwiO1xuaW1wb3J0IHtcbiAgICBTVEFSVF9SRUNPUkRJTkdfU0VTU0lPTixcbiAgICBTVE9QX1JFQ09SRElORyxcbiAgICBHRVRfQ09ERVxufSBmcm9tIFwiLi4vLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQge0Nocm9tZX0gZnJvbSBcIi4uLy4uL3V0aWxzL3R5cGVzXCI7XG5pbXBvcnQge2dldEV2ZW50c0xpc3QsIHNlbmRNZXNzYWdlVG9CYWNrZ3JvdW5kLCBzZW5kTWVzc2FnZVRvUGFnZX0gZnJvbSBcIi4uLy4uL3V0aWxzL21lc3NhZ2VVdGlsXCI7XG5pbXBvcnQge3N0b3BTZXNzaW9ufSBmcm9tIFwiLi4vLi4vdXRpbHMvZG9tXCI7XG5pbXBvcnQge3NlbmRQb3N0RGF0YVdpdGhGb3JtfSBmcm9tIFwiLi4vLi4vdXRpbHMvaGVscGVyc1wiO1xuaW1wb3J0IENvZGVHZW5lcmF0b3IgZnJvbSBcIi4uL2NvZGUtZ2VuZXJhdG9yXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFVJQ29udHJvbGxlckV4dGVuZHN7XG4gICAgc3RhdGU6IGFueTtcbiAgICBkZWZhdWx0U3RhdGU6IGFueSA9IHtzaG93aW5nT25ib2FyZGluZ092ZXJsYXk6IGZhbHNlLCBzZXNzaW9uR29pbmdPbjogZmFsc2V9O1xuICAgIHJlY29yZGluZ092ZXJsYXk6IFJlY29yZGluZ092ZXJsYXk7XG5cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30gYXMgYW55KSB7XG4gICAgICAgIGNvbnN0IHtzaG93aW5nT25ib2FyZGluZ092ZXJsYXksIHNlc3Npb25Hb2luZ09ufSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmRlZmF1bHRTdGF0ZSxcbiAgICAgICAgICAgIHNob3dpbmdPbmJvYXJkaW5nT3ZlcmxheSxcbiAgICAgICAgICAgIHNlc3Npb25Hb2luZ09uXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5yZWNvcmRpbmdPdmVybGF5ID0gbmV3IFJlY29yZGluZ092ZXJsYXkodGhpcywge30pO1xuICAgIH1cblxuICAgIGJvb3QoKXtcbiAgICAgICAgdGhpcy5yZWdpc3RlckV2ZW50cygpO1xuICAgICAgICB0aGlzLnN0YXJ0UmVjb3JkaW5nKCk7XG4gICAgfVxuXG4gICAgcmVnaXN0ZXJFdmVudHMoKXtcbiAgICAgICAgQ2hyb21lLnJ1bnRpbWUub25NZXNzYWdlLmFkZExpc3RlbmVyKHRoaXMuaGFuZGxlSW5jb21pbmdNZXNzYWdlcy5iaW5kKHRoaXMpKTtcbiAgICB9XG5cblxuICAgIGhhbmRsZUluY29taW5nTWVzc2FnZXMocmVxdWVzdDogYW55LCBzZW5kZXI6IGFueSwgc2VuZFJlc3BvbnNlOiBhbnkpe1xuICAgICAgICBjb25zdCB7dHlwZX0gPSByZXF1ZXN0O1xuICAgICAgICBzd2l0Y2godHlwZSl7XG4gICAgICAgICAgICBjYXNlIFNUT1BfUkVDT1JESU5HOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcFJlY29yZGluZygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBHRVRfQ09ERTpcbiAgICAgICAgICAgICAgICBjb25zdCB7ZXZlbnRzfSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgc2VuZFBvc3REYXRhV2l0aEZvcm0oXCJodHRwOi8vbG9jYWxob3N0OjcwMDAvYXBwL2VkaXRvclwiLCB7YWN0aW9uczogZXZlbnRzfSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc2VuZFJlc3BvbnNlKHRydWUpO1xuICAgIH1cblxuICAgIHN0YXJ0UmVjb3JkaW5nKCl7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJTdGFydGluZyByZWNvcmRpbmcgYWN0aW9uc1wiKTtcbiAgICAgICAgY29uc3Qge3Nlc3Npb25Hb2luZ09ufSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHNlbmRNZXNzYWdlVG9CYWNrZ3JvdW5kKHt0eXBlOiBTVEFSVF9SRUNPUkRJTkdfU0VTU0lPTn0sIGZ1bmN0aW9uIChyZXM6YW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNlbnRcIiArIHJlcylcbiAgICAgICAgfSk7XG4gICAgICAgIGlmKHNlc3Npb25Hb2luZ09uKXtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNhbid0IHN0YXJ0IG5ldyByZWNvcmRpbmcgc2Vzc2lvbiB1bnRpbCBjdXJyZW50IHNlc3Npb24gaGFzIGZpbmlzaGVkXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZWNvcmRpbmdPdmVybGF5LmJvb3QoKTtcbiAgICB9XG5cbiAgICBnZXRDb2RlRm9yRXZlbnRzKCl7XG4gICAgICAgIGdldEV2ZW50c0xpc3QoKS50aGVuKChldmVudHMpPT57XG4gICAgICAgICAgICBjb25zdCBfZ2VuZXJhdG9yID0gbmV3IENvZGVHZW5lcmF0b3Ioe30pO1xuICAgICAgICAgICAgc2VuZFBvc3REYXRhV2l0aEZvcm0oXCJodHRwOi8vbG9jYWxob3N0OjcwMDAvYXBwL2VkaXRvclwiLCB7YWN0aW9uczogZXZlbnRzfSlcbiAgICAgICAgICAgIHdpbmRvdy5jbG9zZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdG9wUmVjb3JkaW5nKCl7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJTdG9wcGluZyByZWNvcmRpbmcgYWN0aW9uc1wiKTtcbiAgICAgICAgc3RvcFNlc3Npb24oKTtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmdPdmVybGF5LnNodXREb3duKCk7XG5cbiAgICAgICAgY29uc3QgX292ZXJsYXlDc3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI292ZXJsYXlfY3NzXCIpO1xuICAgICAgICBpZihfb3ZlcmxheUNzcyl7X292ZXJsYXlDc3MucmVtb3ZlKCk7fVxuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFJQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBS0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUpBO0FBQUE7QUFBQTtBQUFBO0FBSUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQVRBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///16\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar DOMEventsToRecord_1 = __webpack_require__(5);\n\nvar messageUtil_1 = __webpack_require__(6);\n\nvar constants_1 = __webpack_require__(2);\n\nvar dom_1 = __webpack_require__(7);\n\nvar EventsController_1 = __webpack_require__(18);\n\nvar formWizard_1 = __webpack_require__(22);\n\nvar createPopper = __webpack_require__(29).createPopper;\n\nvar RecordingOverlay = function () {\n  function RecordingOverlay(controller, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.defaultState = {\n      targetElement: null,\n      sessionGoingOn: false,\n      showingEventsBox: false,\n      pinned: false\n    };\n    this.state = __assign({}, this.defaultState);\n    this.controller = controller;\n    this.handleMouseOver = this.handleMouseOver.bind(this);\n    this.handleAddIconClick = this.handleAddIconClick.bind(this);\n    this.handleEventsGridClick = this.handleEventsGridClick.bind(this);\n    this.takePageScreenShot = this.takePageScreenShot.bind(this);\n    this.handleStopRecordingButtonClick = this.handleStopRecordingButtonClick.bind(this);\n    this.handleDocumentClick = this.handleDocumentClick.bind(this);\n    this.handleInputBlur = this.handleInputBlur.bind(this);\n    this.eventsController = new EventsController_1["default"](this);\n    this.formWizard = new formWizard_1["default"](this, this.eventsController);\n    this.toggleEventsBox = this.toggleEventsBox.bind(this);\n  }\n\n  RecordingOverlay.prototype.getState = function () {\n    return this.state;\n  };\n\n  RecordingOverlay.prototype.toggleEventsBox = function () {\n    if (this._overlayAddEventsContainer.style.display !== "block") {\n      this._arrowOnAddIcon.setAttribute(\'data-hide\', \'\');\n\n      this.showEventsList();\n    } else {\n      this.hideEventsList();\n    }\n  };\n\n  RecordingOverlay.prototype.showAddIcon = function (target) {\n    this.destroyAddTether();\n    this._addActionTether = createPopper(target, this._addActionElement, {\n      placement: \'right-start\',\n      modifiers: [{\n        name: \'flip\',\n        enabled: true\n      }, {\n        name: \'offset\',\n        options: {\n          offset: [-1, 0]\n        }\n      }, {\n        name: \'arrow\',\n        options: {\n          element: this._arrowOnAddIcon\n        }\n      }]\n    });\n    this._addActionElement.style.display = \'block\';\n  };\n\n  RecordingOverlay.prototype.showEventsList = function () {\n    console.debug("Showing events list", this._overlayAddEventsContainer);\n    this._overlayAddEventsContainer.style.display = \'block\';\n    this.state.pinned = true;\n    this._addActionElement.style.height = this._overlayAddEventsContainer.getBoundingClientRect().height + "px";\n    this.destoryEventsListTether();\n    this._eventsListTether = createPopper(this._addActionModal, this._overlayAddEventsContainer, {\n      placement: \'right-start\',\n      modifiers: [{\n        name: \'flip\',\n        enabled: true\n      }]\n    });\n  };\n\n  RecordingOverlay.prototype.hideEventsList = function () {\n    this._arrowOnAddIcon.removeAttribute(\'data-hide\');\n\n    this._overlayAddEventsContainer.style.display = \'none\';\n    this._addActionElement.style.height = "auto";\n    this.state.pinned = false;\n    dom_1.hideAllChildNodes(this._modalContentContainer);\n    this._modalHeading.innerHTML = "Select action";\n\n    this._overlayEventsGrid.removeAttribute("data-gone");\n\n    this.destoryEventsListTether();\n  };\n\n  RecordingOverlay.prototype.destroyAddTether = function () {\n    if (this._addActionTether) {\n      this._addActionTether.destroy();\n\n      this._addActionTether = null;\n    }\n  };\n\n  RecordingOverlay.prototype.destoryEventsListTether = function () {\n    if (this._eventsListTether) {\n      this._eventsListTether.destroy();\n\n      this._eventsListTether = null;\n    }\n  };\n\n  RecordingOverlay.prototype.initNodes = function () {\n    this._modalHeading = document.querySelector(".overlay_heading_container .overlay_heading");\n    this._addActionElement = document.querySelector(\'#overlay_add_action\');\n    this._addActionIcon = document.querySelector(\'#overlay_add\');\n    this._addActionModal = document.querySelector(\'#overlay_add_icon\');\n    this._closeActionIcon = document.querySelector(\'#overlay_add_events_container .overlay_close_icon\');\n    this._overlayAddEventsContainer = document.querySelector("#overlay_add_events_container");\n    this._overlayEventsGrid = document.querySelector("#events_grid");\n    this._pageActionsContainer = document.querySelector("#page_actions");\n    this._stopRecorderButton = document.querySelector("#page_actions #stop_recorder_button");\n    this._takeScreenShotButton = document.querySelector("#page_actions #fullpage_screenshot");\n    this._arrowOnAddIcon = document.querySelector(\'#popper_arrow\');\n    this._modalContentContainer = document.querySelector(".overlay_modal_content");\n  };\n\n  RecordingOverlay.prototype.updateEventTarget = function (target) {\n    this.state = __assign(__assign({}, this.state), {\n      targetElement: target\n    });\n    this.highlightNode(target);\n    this.showAddIcon(target);\n  };\n\n  RecordingOverlay.prototype.highlightNode = function (target) {\n    target.style.outlineStyle = \'solid\';\n    target.style.outlineColor = \'#EC2E6A\';\n    target.style.outlineWidth = \'1px\';\n  };\n\n  RecordingOverlay.prototype.removeHighLightFromNode = function (target) {\n    if (target) {\n      target.style.outlineStyle = \'none\';\n      target.style.outlineColor = \'none\';\n      target.style.outlineWidth = \'0px\';\n    }\n  };\n\n  RecordingOverlay.prototype.handleSelectedActionFromEventsList = function (event) {\n    var action = event.target.getAttribute("data-action");\n\n    switch (action) {\n      case DOMEventsToRecord_1.CLICK:\n        dom_1.removeAllTargetBlankFromLinks();\n        this.eventsController.saveCapturedEventInBackground(DOMEventsToRecord_1.CLICK, this.state.targetElement);\n        this.eventsController.simulateClickOnElement(this.state.targetElement);\n        break;\n\n      case DOMEventsToRecord_1.HOVER:\n        this.eventsController.simulateHoverOnElement(this.state.targetElement);\n        this.eventsController.saveCapturedEventInBackground(DOMEventsToRecord_1.HOVER, this.state.targetElement);\n        break;\n\n      case DOMEventsToRecord_1.SCREENSHOT:\n        this.eventsController.saveCapturedEventInBackground(DOMEventsToRecord_1.SCREENSHOT, this.state.targetElement);\n        break;\n\n      case DOMEventsToRecord_1.SCROLL_TO_VIEW:\n        this.eventsController.saveCapturedEventInBackground(DOMEventsToRecord_1.SCROLL_TO_VIEW, this.state.targetElement);\n        break;\n\n      case DOMEventsToRecord_1.EXTRACT_INFO:\n        return this.formWizard.boot(action);\n\n      case DOMEventsToRecord_1.ASSERT_TEXT:\n        return this.formWizard.boot(action);\n\n      default:\n        break;\n    }\n\n    this.toggleEventsBox();\n  };\n\n  RecordingOverlay.prototype.handleMouseOver = function (event) {\n    if (this._addActionElement.contains(event.target) || event.target.hasAttribute("data-recorder") || this.state.pinned) {\n      return event.preventDefault();\n    }\n\n    var targetElement = this.state.targetElement;\n\n    if (targetElement !== event.target) {\n      this.removeHighLightFromNode(targetElement);\n      this.hideEventsList();\n      this.updateEventTarget(event.target);\n    }\n  };\n\n  RecordingOverlay.prototype.handleAddIconClick = function () {\n    this.toggleEventsBox();\n  };\n\n  RecordingOverlay.prototype.handleEventsGridClick = function (event) {\n    this.handleSelectedActionFromEventsList(event);\n  };\n\n  RecordingOverlay.prototype.handleStopRecordingButtonClick = function (event) {\n    this.controller.getCodeForEvents();\n    messageUtil_1.sendMessageToBackground({\n      type: constants_1.DELETE_RECORDING_SESSION\n    });\n    this.controller.stopRecording();\n  };\n\n  RecordingOverlay.prototype.handleDocumentClick = function (event) {\n    var isRecorder = event.target.getAttribute(\'data-recorder\');\n\n    if (!isRecorder) {\n      this.state.pinned = false;\n      var target = event.target;\n\n      if (!event.simulatedEvent) {\n        this.eventsController.saveCapturedEventInBackground(DOMEventsToRecord_1.CLICK, event.target);\n      }\n    }\n  };\n\n  RecordingOverlay.prototype.handleInputBlur = function (event) {\n    var isRecorder = event.target.getAttribute(\'data-recorder\');\n\n    if (!isRecorder) {\n      var targetElement = event.target;\n\n      if ((targetElement.tagName === "INPUT" || targetElement.tagName === "TEXTAREA") && targetElement.value) {\n        this.eventsController.saveCapturedEventInBackground(DOMEventsToRecord_1.INPUT, event.target, targetElement.value);\n      }\n    }\n  };\n\n  RecordingOverlay.prototype.registerNodeListeners = function () {\n    document.body.addEventListener("mousemove", this.handleMouseOver, true);\n    document.body.addEventListener("blur", this.handleInputBlur, true);\n    document.addEventListener("click", this.handleDocumentClick, true);\n\n    this._addActionIcon.addEventListener("click", this.handleAddIconClick);\n\n    this._overlayEventsGrid.addEventListener("click", this.handleEventsGridClick, true);\n\n    this._closeActionIcon.addEventListener("click", this.toggleEventsBox, true);\n\n    this._takeScreenShotButton.addEventListener("click", this.takePageScreenShot);\n\n    this._stopRecorderButton.addEventListener("click", this.handleStopRecordingButtonClick);\n  };\n\n  RecordingOverlay.prototype.takePageScreenShot = function () {\n    this.eventsController.saveCapturedEventInBackground(DOMEventsToRecord_1.PAGE_SCREENSHOT, document.body, document.title);\n  };\n\n  RecordingOverlay.prototype.removeNodeListeners = function () {\n    document.body.removeEventListener("mousemove", this.handleMouseOver, true);\n\n    this._addActionIcon.removeEventListener("click", this.handleAddIconClick);\n\n    this._overlayEventsGrid.removeEventListener("click", this.handleEventsGridClick, true);\n\n    this._takeScreenShotButton.removeEventListener("click", this.takePageScreenShot);\n\n    this._stopRecorderButton.removeEventListener("click", this.handleStopRecordingButtonClick);\n  };\n\n  RecordingOverlay.prototype.boot = function () {\n    this.initNodes();\n    this.registerNodeListeners();\n    messageUtil_1.sendMessageToBackground({\n      type: constants_1.START_RECORDING_SESSION\n    }, function (res) {\n      console.log(res);\n    });\n    this.eventsController.saveCapturedEventInBackground(DOMEventsToRecord_1.NAVIGATE_URL, document.body, window.location.href);\n    console.info("Info Overlay booted up");\n  };\n\n  RecordingOverlay.prototype.removeNodes = function () {\n    if (this._addActionElement) {\n      this._addActionElement.remove();\n    }\n\n    if (this._pageActionsContainer) {\n      this._pageActionsContainer.remove();\n    }\n  };\n\n  RecordingOverlay.prototype.shutDown = function () {\n    var targetElement = this.state.targetElement;\n    console.debug("Shutting down Recording Overlay");\n    this.removeNodeListeners();\n\n    if (targetElement) {\n      this.removeHighLightFromNode(targetElement);\n    }\n\n    this.removeNodes();\n    this.state = __assign(__assign({}, this.state), {\n      sessionGoingOn: false\n    });\n  };\n\n  return RecordingOverlay;\n}();\n\nexports["default"] = RecordingOverlay;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9pbmplY3QvdWkvcmVjb3JkaW5nT3ZlcmxheS50cz9hMmFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQVNTRVJUX1RFWFQsXG4gICAgQ0xJQ0ssIEVYVFJBQ1RfSU5GTyxcbiAgICBIT1ZFUiwgSU5QVVQsXG4gICAgTkFWSUdBVEVfVVJMLFxuICAgIFBBR0VfU0NSRUVOU0hPVCxcbiAgICBTQ1JFRU5TSE9ULFxuICAgIFNDUk9MTF9UT19WSUVXXG59IGZyb20gXCIuLi8uLi8uLi9jb25zdGFudHMvRE9NRXZlbnRzVG9SZWNvcmRcIjtcbmltcG9ydCB7c2VuZE1lc3NhZ2VUb0JhY2tncm91bmR9IGZyb20gXCIuLi8uLi8uLi91dGlscy9tZXNzYWdlVXRpbFwiO1xuaW1wb3J0IHtERUxFVEVfUkVDT1JESU5HX1NFU1NJT04sIEVWRU5UX0NBUFRVUkVELCBTVEFSVF9SRUNPUkRJTkdfU0VTU0lPTiwgU1RPUF9SRUNPUkRJTkd9IGZyb20gXCIuLi8uLi8uLi9jb25zdGFudHNcIjtcbmltcG9ydCB7aGlkZUFsbENoaWxkTm9kZXMsIHJlbW92ZUFsbFRhcmdldEJsYW5rRnJvbUxpbmtzLCBzZXRBdHRyaWJ1dGVGb3JBbGxDaGlsZE5vZGVzfSBmcm9tIFwiLi4vLi4vLi4vdXRpbHMvZG9tXCI7XG5pbXBvcnQgVUlDb250cm9sbGVyIGZyb20gXCIuLi9VSUNvbnRyb2xsZXJcIjtcbmltcG9ydCB7Y3JlYXRlU25hY2tCYXJ9IGZyb20gXCIuLi90b2FzdFwiO1xuaW1wb3J0IEV2ZW50c0NvbnRyb2xsZXIgZnJvbSBcIi4uL0V2ZW50c0NvbnRyb2xsZXJcIjtcbmltcG9ydCBGb3JtV2l6YXJkIGZyb20gXCIuL2Zvcm1XaXphcmRcIjtcbmNvbnN0IHtjcmVhdGVQb3BwZXJ9ICA9IHJlcXVpcmUoXCJAcG9wcGVyanMvY29yZVwiKTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVjb3JkaW5nT3ZlcmxheXtcbiAgICBkZWZhdWx0U3RhdGU6IGFueSA9IHt0YXJnZXRFbGVtZW50OiBudWxsLCBzZXNzaW9uR29pbmdPbjogZmFsc2UsIHNob3dpbmdFdmVudHNCb3g6IGZhbHNlLCBwaW5uZWQ6IGZhbHNlfTtcblxuICAgIHByaXZhdGUgc3RhdGU6IGFueTtcbiAgICBwcml2YXRlIGV2ZW50c0NvbnRyb2xsZXI6IEV2ZW50c0NvbnRyb2xsZXI7XG4gICAgcHJpdmF0ZSBmb3JtV2l6YXJkOiBGb3JtV2l6YXJkO1xuXG4gICAgcHJpdmF0ZSBjb250cm9sbGVyOiBhbnk7XG4gICAgcHJpdmF0ZSBfb3ZlcmxheUFkZEV2ZW50c0NvbnRhaW5lcjogYW55O1xuICAgIHByaXZhdGUgX21vZGFsQ29udGVudENvbnRhaW5lcjogYW55O1xuXG4gICAgcHJpdmF0ZSBfYWRkQWN0aW9uRWxlbWVudDogYW55O1xuICAgIHByaXZhdGUgX2FkZEFjdGlvbjogYW55O1xuICAgIHByaXZhdGUgX2Nsb3NlQWN0aW9uSWNvbjogYW55O1xuICAgIHByaXZhdGUgX2FkZEFjdGlvbkljb246IGFueTtcbiAgICBwcml2YXRlIF9vdmVybGF5RXZlbnRzR3JpZDogYW55O1xuICAgIHByaXZhdGUgX3BhZ2VBY3Rpb25zQ29udGFpbmVyOiBhbnk7XG4gICAgcHJpdmF0ZSBfc3RvcFJlY29yZGVyQnV0dG9uOiBhbnk7XG4gICAgcHJpdmF0ZSBfYWRkQWN0aW9uVGV0aGVyOiBhbnk7XG4gICAgcHJpdmF0ZSBfZXZlbnRzTGlzdFRldGhlcjogYW55O1xuICAgIHByaXZhdGUgX3Rha2VTY3JlZW5TaG90QnV0dG9uOiBhbnk7XG4gICAgcHJpdmF0ZSBfYWRkQWN0aW9uTW9kYWw6IGFueTtcblxuICAgIHByaXZhdGUgX2Fycm93T25BZGRJY29uOiBhbnk7XG4gICAgcHJpdmF0ZSBfbW9kYWxIZWFkaW5nOiBhbnk7XG5cbiAgICBjb25zdHJ1Y3Rvcihjb250cm9sbGVyOiBVSUNvbnRyb2xsZXIsIG9wdGlvbnMgPSB7fSBhcyBhbnkpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9e1xuICAgICAgICAgICAgLi4udGhpcy5kZWZhdWx0U3RhdGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gY29udHJvbGxlcjtcblxuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlT3ZlciA9IHRoaXMuaGFuZGxlTW91c2VPdmVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlQWRkSWNvbkNsaWNrID0gdGhpcy5oYW5kbGVBZGRJY29uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVFdmVudHNHcmlkQ2xpY2sgPSB0aGlzLmhhbmRsZUV2ZW50c0dyaWRDbGljay5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRha2VQYWdlU2NyZWVuU2hvdCA9IHRoaXMudGFrZVBhZ2VTY3JlZW5TaG90LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlU3RvcFJlY29yZGluZ0J1dHRvbkNsaWNrID0gdGhpcy5oYW5kbGVTdG9wUmVjb3JkaW5nQnV0dG9uQ2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrID0gdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlSW5wdXRCbHVyID0gdGhpcy5oYW5kbGVJbnB1dEJsdXIuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ldmVudHNDb250cm9sbGVyID0gbmV3IEV2ZW50c0NvbnRyb2xsZXIodGhpcyk7XG4gICAgICAgIHRoaXMuZm9ybVdpemFyZCA9IG5ldyBGb3JtV2l6YXJkKHRoaXMsIHRoaXMuZXZlbnRzQ29udHJvbGxlcik7XG4gICAgICAgIHRoaXMudG9nZ2xlRXZlbnRzQm94ID0gdGhpcy50b2dnbGVFdmVudHNCb3guYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBnZXRTdGF0ZSgpe1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgICB9XG5cbiAgICB0b2dnbGVFdmVudHNCb3goKXtcbiAgICAgICAgaWYodGhpcy5fb3ZlcmxheUFkZEV2ZW50c0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ICE9PSBcImJsb2NrXCIpe1xuICAgICAgICAgICAgdGhpcy5fYXJyb3dPbkFkZEljb24uc2V0QXR0cmlidXRlKCdkYXRhLWhpZGUnLCAnJyk7XG4gICAgICAgICAgICB0aGlzLnNob3dFdmVudHNMaXN0KClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZUV2ZW50c0xpc3QoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNob3dBZGRJY29uKHRhcmdldDogYW55KXtcbiAgICAgICAgdGhpcy5kZXN0cm95QWRkVGV0aGVyKCk7XG5cbiAgICAgICAgdGhpcy5fYWRkQWN0aW9uVGV0aGVyID0gY3JlYXRlUG9wcGVyKHRhcmdldCwgdGhpcy5fYWRkQWN0aW9uRWxlbWVudCwge1xuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogJ3JpZ2h0LXN0YXJ0JyxcbiAgICAgICAgICAgICAgICBtb2RpZmllcnM6IFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ2ZsaXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBbLTEsIDBdXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICdhcnJvdycsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5fYXJyb3dPbkFkZEljb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hZGRBY3Rpb25FbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgIH1cblxuICAgIHNob3dFdmVudHNMaXN0KCl7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoXCJTaG93aW5nIGV2ZW50cyBsaXN0XCIsIHRoaXMuX292ZXJsYXlBZGRFdmVudHNDb250YWluZXIpO1xuICAgICAgICB0aGlzLl9vdmVybGF5QWRkRXZlbnRzQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLnN0YXRlLnBpbm5lZCA9IHRydWU7XG5cbiAgICAgICAgLy8gSW5jcmVhc2UgdGhlIGhlaWdodCBvZiBhY3Rpb25zIGNvbnRhaW5lciB0byBnaXZlIG1vcmUgc3BhY2UgZm9yIG5vdCBmYWxsaW5nIG91dCBvZiBzZWxlY3Rpb24uXG4gICAgICAgIHRoaXMuX2FkZEFjdGlvbkVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5fb3ZlcmxheUFkZEV2ZW50c0NvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgKyBcInB4XCI7XG5cbiAgICAgICAgdGhpcy5kZXN0b3J5RXZlbnRzTGlzdFRldGhlcigpO1xuICAgICAgICB0aGlzLl9ldmVudHNMaXN0VGV0aGVyID0gIGNyZWF0ZVBvcHBlcih0aGlzLl9hZGRBY3Rpb25Nb2RhbCwgdGhpcy5fb3ZlcmxheUFkZEV2ZW50c0NvbnRhaW5lciwge1xuICAgICAgICAgICAgcGxhY2VtZW50OiAncmlnaHQtc3RhcnQnLFxuICAgICAgICAgICAgbW9kaWZpZXJzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiAnZmxpcCcsXG4gICAgICAgICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF19KTtcbiAgICB9XG5cbiAgICBoaWRlRXZlbnRzTGlzdCgpe1xuICAgICAgICB0aGlzLl9hcnJvd09uQWRkSWNvbi5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtaGlkZScpO1xuICAgICAgICB0aGlzLl9vdmVybGF5QWRkRXZlbnRzQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMuX2FkZEFjdGlvbkVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gXCJhdXRvXCI7XG4gICAgICAgIHRoaXMuc3RhdGUucGlubmVkID0gZmFsc2U7XG5cbiAgICAgICAgaGlkZUFsbENoaWxkTm9kZXModGhpcy5fbW9kYWxDb250ZW50Q29udGFpbmVyKTtcbiAgICAgICAgdGhpcy5fbW9kYWxIZWFkaW5nLmlubmVySFRNTCA9IFwiU2VsZWN0IGFjdGlvblwiO1xuICAgICAgICB0aGlzLl9vdmVybGF5RXZlbnRzR3JpZC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWdvbmVcIik7XG4gICAgICAgIHRoaXMuZGVzdG9yeUV2ZW50c0xpc3RUZXRoZXIoKTtcbiAgICB9XG5cbiAgICBkZXN0cm95QWRkVGV0aGVyKCl7XG4gICAgICAgIGlmKHRoaXMuX2FkZEFjdGlvblRldGhlcil7XG4gICAgICAgIHRoaXMuX2FkZEFjdGlvblRldGhlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuX2FkZEFjdGlvblRldGhlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkZXN0b3J5RXZlbnRzTGlzdFRldGhlcigpe1xuICAgICAgICBpZih0aGlzLl9ldmVudHNMaXN0VGV0aGVyKXtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50c0xpc3RUZXRoZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzTGlzdFRldGhlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpbml0Tm9kZXMoKXtcbiAgICAgICAgdGhpcy5fbW9kYWxIZWFkaW5nID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5vdmVybGF5X2hlYWRpbmdfY29udGFpbmVyIC5vdmVybGF5X2hlYWRpbmdcIik7XG4gICAgICAgIHRoaXMuX2FkZEFjdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3ZlcmxheV9hZGRfYWN0aW9uJyk7XG4gICAgICAgIHRoaXMuX2FkZEFjdGlvbkljb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3ZlcmxheV9hZGQnKTtcbiAgICAgICAgdGhpcy5fYWRkQWN0aW9uTW9kYWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3ZlcmxheV9hZGRfaWNvbicpO1xuICAgICAgICB0aGlzLl9jbG9zZUFjdGlvbkljb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjb3ZlcmxheV9hZGRfZXZlbnRzX2NvbnRhaW5lciAub3ZlcmxheV9jbG9zZV9pY29uJyk7XG4gICAgICAgIHRoaXMuX292ZXJsYXlBZGRFdmVudHNDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI292ZXJsYXlfYWRkX2V2ZW50c19jb250YWluZXJcIik7XG4gICAgICAgIHRoaXMuX292ZXJsYXlFdmVudHNHcmlkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNldmVudHNfZ3JpZFwiKTtcbiAgICAgICAgdGhpcy5fcGFnZUFjdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3BhZ2VfYWN0aW9uc1wiKTtcbiAgICAgICAgdGhpcy5fc3RvcFJlY29yZGVyQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNwYWdlX2FjdGlvbnMgI3N0b3BfcmVjb3JkZXJfYnV0dG9uXCIpO1xuICAgICAgICB0aGlzLl90YWtlU2NyZWVuU2hvdEJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcGFnZV9hY3Rpb25zICNmdWxscGFnZV9zY3JlZW5zaG90XCIpO1xuICAgICAgICB0aGlzLl9hcnJvd09uQWRkSWNvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNwb3BwZXJfYXJyb3cnKTtcbiAgICAgICAgdGhpcy5fbW9kYWxDb250ZW50Q29udGFpbmVyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5vdmVybGF5X21vZGFsX2NvbnRlbnRcIik7XG4gICAgfVxuXG4gICAgdXBkYXRlRXZlbnRUYXJnZXQodGFyZ2V0OiBIVE1MRWxlbWVudCl7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudDogdGFyZ2V0XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGlnaGxpZ2h0Tm9kZSh0YXJnZXQpO1xuICAgICAgICB0aGlzLnNob3dBZGRJY29uKHRhcmdldCk7XG4gICAgfVxuXG4gICAgaGlnaGxpZ2h0Tm9kZSh0YXJnZXQ6IEhUTUxFbGVtZW50KXtcbiAgICAgICAgdGFyZ2V0LnN0eWxlLm91dGxpbmVTdHlsZSA9ICdzb2xpZCc7XG4gICAgICAgIHRhcmdldC5zdHlsZS5vdXRsaW5lQ29sb3IgPSAnI0VDMkU2QSc7XG4gICAgICAgIHRhcmdldC5zdHlsZS5vdXRsaW5lV2lkdGggPSAnMXB4JztcbiAgICB9XG5cbiAgICByZW1vdmVIaWdoTGlnaHRGcm9tTm9kZSh0YXJnZXQ6IEhUTUxFbGVtZW50KXtcbiAgICAgICAgLy8gQEZJWE1FOiBXaGF0IGlmIHRoZSB0YXJnZXQgaGFkIHNldCBvdXRsaW5lQ29sb3IgYW5kIG91dGxpbmVTdHlsZUJlZm9yZS5cbiAgICAgICAgaWYodGFyZ2V0KSB7XG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUub3V0bGluZVN0eWxlID0gJ25vbmUnO1xuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLm91dGxpbmVDb2xvciA9ICdub25lJztcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5vdXRsaW5lV2lkdGggPSAnMHB4JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVNlbGVjdGVkQWN0aW9uRnJvbUV2ZW50c0xpc3QoZXZlbnQ6IGFueSl7XG4gICAgICAgY29uc3QgYWN0aW9uID0gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtYWN0aW9uXCIpO1xuICAgICAgICBzd2l0Y2goYWN0aW9uKXtcbiAgICAgICAgICAgY2FzZSBDTElDSzpcbiAgICAgICAgICAgICAgICByZW1vdmVBbGxUYXJnZXRCbGFua0Zyb21MaW5rcygpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzQ29udHJvbGxlci5zYXZlQ2FwdHVyZWRFdmVudEluQmFja2dyb3VuZChDTElDSywgdGhpcy5zdGF0ZS50YXJnZXRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c0NvbnRyb2xsZXIuc2ltdWxhdGVDbGlja09uRWxlbWVudCh0aGlzLnN0YXRlLnRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgSE9WRVI6XG4gICAgICAgICAgICAgICB0aGlzLmV2ZW50c0NvbnRyb2xsZXIuc2ltdWxhdGVIb3Zlck9uRWxlbWVudCh0aGlzLnN0YXRlLnRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgdGhpcy5ldmVudHNDb250cm9sbGVyLnNhdmVDYXB0dXJlZEV2ZW50SW5CYWNrZ3JvdW5kKEhPVkVSLCB0aGlzLnN0YXRlLnRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgU0NSRUVOU0hPVDpcbiAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzQ29udHJvbGxlci5zYXZlQ2FwdHVyZWRFdmVudEluQmFja2dyb3VuZChTQ1JFRU5TSE9ULCB0aGlzLnN0YXRlLnRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgIGNhc2UgU0NST0xMX1RPX1ZJRVc6XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHNDb250cm9sbGVyLnNhdmVDYXB0dXJlZEV2ZW50SW5CYWNrZ3JvdW5kKFNDUk9MTF9UT19WSUVXLCB0aGlzLnN0YXRlLnRhcmdldEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEVYVFJBQ1RfSU5GTzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtV2l6YXJkLmJvb3QoYWN0aW9uKTtcbiAgICAgICAgICAgIGNhc2UgQVNTRVJUX1RFWFQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybVdpemFyZC5ib290KGFjdGlvbik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgIH1cbiAgICAgICB0aGlzLnRvZ2dsZUV2ZW50c0JveCgpO1xuICAgIH1cblxuICAgIGhhbmRsZU1vdXNlT3ZlcihldmVudDogTW91c2VFdmVudCl7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYodGhpcy5fYWRkQWN0aW9uRWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpIHx8IGV2ZW50LnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlY29yZGVyXCIpIHx8IHRoaXMuc3RhdGUucGlubmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7dGFyZ2V0RWxlbWVudH0gPSB0aGlzLnN0YXRlO1xuXG4gICAgICAgIGlmKHRhcmdldEVsZW1lbnQgIT09IGV2ZW50LnRhcmdldCl7XG4gICAgICAgICAgICAvLyBSZW1vdmUgSGlnaGxpZ2h0IGZyb20gbGFzdCBlbGVtZW50IGhvdmVyZWRcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSGlnaExpZ2h0RnJvbU5vZGUodGFyZ2V0RWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmhpZGVFdmVudHNMaXN0KCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUV2ZW50VGFyZ2V0KGV2ZW50LnRhcmdldCBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBoYW5kbGVBZGRJY29uQ2xpY2soKXtcbiAgICAgICAgdGhpcy50b2dnbGVFdmVudHNCb3goKTtcbiAgICB9XG5cbiAgICBoYW5kbGVFdmVudHNHcmlkQ2xpY2soZXZlbnQ6IEV2ZW50KXtcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3RlZEFjdGlvbkZyb21FdmVudHNMaXN0KGV2ZW50KTtcbiAgICB9XG5cbiAgICBoYW5kbGVTdG9wUmVjb3JkaW5nQnV0dG9uQ2xpY2soZXZlbnQ6IGFueSl7XG4gICAgICAgIHRoaXMuY29udHJvbGxlci5nZXRDb2RlRm9yRXZlbnRzKCk7XG4gICAgICAgIHNlbmRNZXNzYWdlVG9CYWNrZ3JvdW5kKHt0eXBlOiBERUxFVEVfUkVDT1JESU5HX1NFU1NJT059KTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyLnN0b3BSZWNvcmRpbmcoKTtcbiAgICB9XG5cbiAgICBoYW5kbGVEb2N1bWVudENsaWNrKGV2ZW50OiBhbnkpe1xuICAgICAgICBjb25zdCBpc1JlY29yZGVyID0gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1yZWNvcmRlcicpO1xuICAgICAgICBpZighaXNSZWNvcmRlcil7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnBpbm5lZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qge3RhcmdldH0gPSBldmVudDtcbiAgICAgICAgICAgIGlmKCFldmVudC5zaW11bGF0ZWRFdmVudCl7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHNDb250cm9sbGVyLnNhdmVDYXB0dXJlZEV2ZW50SW5CYWNrZ3JvdW5kKENMSUNLLCBldmVudC50YXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlSW5wdXRCbHVyKGV2ZW50OiBhbnkpe1xuICAgICAgICBjb25zdCBpc1JlY29yZGVyID0gZXZlbnQudGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1yZWNvcmRlcicpO1xuICAgICAgICBpZighaXNSZWNvcmRlcil7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgaWYoKHRhcmdldEVsZW1lbnQudGFnTmFtZSA9PT0gXCJJTlBVVFwiIHx8IHRhcmdldEVsZW1lbnQudGFnTmFtZSA9PT0gXCJURVhUQVJFQVwiKSAmJiB0YXJnZXRFbGVtZW50LnZhbHVlKXtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50c0NvbnRyb2xsZXIuc2F2ZUNhcHR1cmVkRXZlbnRJbkJhY2tncm91bmQoSU5QVVQsIGV2ZW50LnRhcmdldCwgdGFyZ2V0RWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZWdpc3Rlck5vZGVMaXN0ZW5lcnMoKXtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuaGFuZGxlTW91c2VPdmVyLCB0cnVlKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLmhhbmRsZUlucHV0Qmx1ciwgdHJ1ZSk7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJjbGlja1wiLCB0aGlzLmhhbmRsZURvY3VtZW50Q2xpY2ssIHRydWUpO1xuXG4gICAgICAgIHRoaXMuX2FkZEFjdGlvbkljb24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuaGFuZGxlQWRkSWNvbkNsaWNrKTtcblxuICAgICAgICAgdGhpcy5fb3ZlcmxheUV2ZW50c0dyaWQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuaGFuZGxlRXZlbnRzR3JpZENsaWNrLCB0cnVlKTtcbiAgICAgICAgIHRoaXMuX2Nsb3NlQWN0aW9uSWNvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy50b2dnbGVFdmVudHNCb3gsIHRydWUpO1xuICAgICAgICAgdGhpcy5fdGFrZVNjcmVlblNob3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMudGFrZVBhZ2VTY3JlZW5TaG90KTtcbiAgICAgICAgIHRoaXMuX3N0b3BSZWNvcmRlckJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5oYW5kbGVTdG9wUmVjb3JkaW5nQnV0dG9uQ2xpY2spO1xuICAgIH1cblxuICAgIHRha2VQYWdlU2NyZWVuU2hvdCgpe1xuICAgICAgICB0aGlzLmV2ZW50c0NvbnRyb2xsZXIuc2F2ZUNhcHR1cmVkRXZlbnRJbkJhY2tncm91bmQoUEFHRV9TQ1JFRU5TSE9ULCBkb2N1bWVudC5ib2R5LCBkb2N1bWVudC50aXRsZSk7XG4gICAgfVxuXG4gICAgcmVtb3ZlTm9kZUxpc3RlbmVycygpe1xuICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5oYW5kbGVNb3VzZU92ZXIsIHRydWUpO1xuICAgICAgICB0aGlzLl9hZGRBY3Rpb25JY29uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmhhbmRsZUFkZEljb25DbGljayk7XG4gICAgICAgIHRoaXMuX292ZXJsYXlFdmVudHNHcmlkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmhhbmRsZUV2ZW50c0dyaWRDbGljaywgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3Rha2VTY3JlZW5TaG90QnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLnRha2VQYWdlU2NyZWVuU2hvdCk7XG4gICAgICAgIHRoaXMuX3N0b3BSZWNvcmRlckJ1dHRvbi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5oYW5kbGVTdG9wUmVjb3JkaW5nQnV0dG9uQ2xpY2spO1xuICAgIH1cblxuICAgIGJvb3QoKXtcbiAgICAgICAgdGhpcy5pbml0Tm9kZXMoKTtcbiAgICAgICAgdGhpcy5yZWdpc3Rlck5vZGVMaXN0ZW5lcnMoKTtcbiAgICAgICAgc2VuZE1lc3NhZ2VUb0JhY2tncm91bmQoe1xuICAgICAgICAgICAgdHlwZTogU1RBUlRfUkVDT1JESU5HX1NFU1NJT04sXG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZXM6IGFueSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cocmVzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ldmVudHNDb250cm9sbGVyLnNhdmVDYXB0dXJlZEV2ZW50SW5CYWNrZ3JvdW5kKE5BVklHQVRFX1VSTCwgZG9jdW1lbnQuYm9keSwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgICAgIGNvbnNvbGUuaW5mbyhcIkluZm8gT3ZlcmxheSBib290ZWQgdXBcIik7XG4gICAgfVxuXG4gICAgcmVtb3ZlTm9kZXMoKXtcbiAgICAgICAgaWYodGhpcy5fYWRkQWN0aW9uRWxlbWVudCl7XG4gICAgICAgICAgICB0aGlzLl9hZGRBY3Rpb25FbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmKHRoaXMuX3BhZ2VBY3Rpb25zQ29udGFpbmVyKXtcbiAgICAgICAgICAgIHRoaXMuX3BhZ2VBY3Rpb25zQ29udGFpbmVyLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2h1dERvd24oKXtcbiAgICAgICAgY29uc3Qge3RhcmdldEVsZW1lbnR9ID0gdGhpcy5zdGF0ZTtcblxuICAgICAgICBjb25zb2xlLmRlYnVnKFwiU2h1dHRpbmcgZG93biBSZWNvcmRpbmcgT3ZlcmxheVwiKTtcbiAgICAgICAgdGhpcy5yZW1vdmVOb2RlTGlzdGVuZXJzKCk7XG4gICAgICAgIGlmKHRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlSGlnaExpZ2h0RnJvbU5vZGUodGFyZ2V0RWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVOb2RlcygpO1xuXG4gICAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnN0YXRlLFxuICAgICAgICAgICAgc2Vzc2lvbkdvaW5nT246IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxufVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQVFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBMEJBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUExQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBMEJBO0FBR0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFGQTtBQUtBO0FBQ0E7QUFDQTtBQURBO0FBRkE7QUFPQTtBQUNBO0FBQ0E7QUFEQTtBQUZBO0FBYkE7QUFxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUZBO0FBSEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBREE7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQXJCQTtBQUNBO0FBc0JBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFFQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUVBO0FBREE7QUFHQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar messageUtil_1 = __webpack_require__(6);\n\nvar constants_1 = __webpack_require__(2);\n\nvar toast_1 = __webpack_require__(19);\n\nvar helpers_1 = __webpack_require__(4);\n\nvar finder_1 = __webpack_require__(20);\n\nvar EventsController = function () {\n  function EventsController(recordingOverlay) {\n    this.recordingOverlay = recordingOverlay;\n  }\n\n  EventsController.prototype.simulateClickOnElement = function (element) {\n    try {\n      var event_1 = new MouseEvent("click", {\n        "view": window,\n        "bubbles": true,\n        "cancelable": false\n      });\n      event_1.simulatedEvent = true;\n      element.dispatchEvent(event_1);\n    } catch (err) {\n      console.error(element, err);\n      return;\n    }\n  };\n\n  EventsController.prototype.simulateHoverOnElement = function (el) {\n    try {\n      var event_2 = new Event(\'MS\');\n      event_2.initEvent("mouseover", true, true);\n      el.dispatchEvent(event_2);\n    } catch (err) {\n      console.error(el, err);\n      return;\n    }\n  };\n\n  EventsController.prototype.saveCapturedEventInBackground = function (event_type, capturedTarget, value, callback) {\n    if (value === void 0) {\n      value = "";\n    }\n\n    var optimizedMinLength = capturedTarget.id ? 2 : 10;\n    var selector = capturedTarget ? finder_1["default"](capturedTarget, {\n      seedMinLength: 5,\n      optimizedMinLength: optimizedMinLength\n    }) : null;\n    messageUtil_1.sendMessageToBackground({\n      type: constants_1.EVENT_CAPTURED,\n      payload: {\n        event_type: event_type,\n        selector: selector,\n        value: value ? value : null\n      }\n    }, function (res) {\n      toast_1.createSnackBar(helpers_1.getSentenceCaseString(event_type) + " action has been recorded", "Dismiss");\n\n      if (callback) {\n        callback();\n      }\n    });\n  };\n\n  return EventsController;\n}();\n\nexports["default"] = EventsController;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9pbmplY3QvRXZlbnRzQ29udHJvbGxlci50cz9mMmYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7c2VuZE1lc3NhZ2VUb0JhY2tncm91bmR9IGZyb20gXCIuLi8uLi91dGlscy9tZXNzYWdlVXRpbFwiO1xuaW1wb3J0IHtFVkVOVF9DQVBUVVJFRH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50c1wiO1xuaW1wb3J0IHtDTElDS30gZnJvbSBcIi4uLy4uL2NvbnN0YW50cy9ET01FdmVudHNUb1JlY29yZFwiO1xuaW1wb3J0IHtjcmVhdGVTbmFja0Jhcn0gZnJvbSBcIi4vdG9hc3RcIjtcbmltcG9ydCB7Z2V0U2VudGVuY2VDYXNlU3RyaW5nfSBmcm9tIFwiLi4vLi4vdXRpbHMvaGVscGVyc1wiO1xuaW1wb3J0IFJlY29yZGluZ092ZXJsYXkgZnJvbSBcIi4vdWkvcmVjb3JkaW5nT3ZlcmxheVwiO1xuaW1wb3J0IGZpbmRlciBmcm9tICdAbWVkdi9maW5kZXInXG5pbXBvcnQgRm9ybVdpemFyZCBmcm9tIFwiLi91aS9mb3JtV2l6YXJkXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50c0NvbnRyb2xsZXIge1xuICAgIHJlY29yZGluZ092ZXJsYXk6IFJlY29yZGluZ092ZXJsYXk7XG5cbiAgICBjb25zdHJ1Y3RvcihyZWNvcmRpbmdPdmVybGF5OiBSZWNvcmRpbmdPdmVybGF5KSB7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nT3ZlcmxheSA9IHJlY29yZGluZ092ZXJsYXk7XG4gICAgfVxuXG4gICAgc2ltdWxhdGVDbGlja09uRWxlbWVudChlbGVtZW50OiBhbnkpe1xuICAgICAgICB0cnl7XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBNb3VzZUV2ZW50KFwiY2xpY2tcIiwge1xuICAgICAgICAgICAgICAgIFwidmlld1wiOiB3aW5kb3csXG4gICAgICAgICAgICAgICAgXCJidWJibGVzXCI6IHRydWUsXG4gICAgICAgICAgICAgICAgXCJjYW5jZWxhYmxlXCI6IGZhbHNlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gQWRkIHRoaXMgcHJvcGVydHkgc28gdGhhdCBnbG9iYWwgY2xpY2sgbGlzdGVuZXJcbiAgICAgICAgICAgIC8vIHJlY29nbml6ZXMgdGhpcyBpcyBhbnMgc2ltdWxhdGVkIGV2ZW50LlxuICAgICAgICAgICAgKGV2ZW50IGFzIGFueSkuc2ltdWxhdGVkRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfSBjYXRjaChlcnIpe1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlbGVtZW50LCBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2ltdWxhdGVIb3Zlck9uRWxlbWVudChlbDogYW55KXtcbiAgICAgICAgdHJ5e1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ01TJyk7XG4gICAgICAgICAgICBldmVudC5pbml0RXZlbnQoXCJtb3VzZW92ZXJcIix0cnVlLHRydWUpO1xuICAgICAgICAgICAgZWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH0gY2F0Y2goZXJyKXtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZWwsIGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzYXZlQ2FwdHVyZWRFdmVudEluQmFja2dyb3VuZChldmVudF90eXBlOiBzdHJpbmcsIGNhcHR1cmVkVGFyZ2V0OiBhbnksIHZhbHVlOiBhbnkgPSBcIlwiLCBjYWxsYmFjaz86IGFueSl7XG4gICAgICAgIGNvbnN0IG9wdGltaXplZE1pbkxlbmd0aCA9IChjYXB0dXJlZFRhcmdldC5pZCkgPyAyIDogMTAgLy8gaWYgdGhlIHRhcmdldCBoYXMgYW4gaWQsIHVzZSB0aGF0IGluc3RlYWQgb2YgbXVsdGlwbGUgb3RoZXIgc2VsZWN0b3JzXG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gY2FwdHVyZWRUYXJnZXQgPyBmaW5kZXIoY2FwdHVyZWRUYXJnZXQsIHtzZWVkTWluTGVuZ3RoOiA1LCBvcHRpbWl6ZWRNaW5MZW5ndGg6IG9wdGltaXplZE1pbkxlbmd0aH0pIDogbnVsbDtcblxuICAgICAgICBzZW5kTWVzc2FnZVRvQmFja2dyb3VuZCh7dHlwZTogRVZFTlRfQ0FQVFVSRUQsIHBheWxvYWQ6IHtldmVudF90eXBlOiBldmVudF90eXBlLCBzZWxlY3RvciwgdmFsdWU6IHZhbHVlID8gdmFsdWUgOiBudWxsfX0sICAocmVzOiBhbnkpID0+IHtcbiAgICAgICAgICAgIGNyZWF0ZVNuYWNrQmFyKGAke2dldFNlbnRlbmNlQ2FzZVN0cmluZyhldmVudF90eXBlKX0gYWN0aW9uIGhhcyBiZWVuIHJlY29yZGVkYCwgXCJEaXNtaXNzXCIpO1xuICAgICAgICAgICAgaWYoY2FsbGJhY2spe1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///18\n')},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\nvar previous = null;\n\nfunction createSnackBar(message, actionText, action) {\n  if (previous) {\n    previous.dismiss();\n  }\n\n  var snackbar = document.createElement(\'div\');\n  snackbar.className = \'paper-snackbar\';\n  snackbar.setAttribute("data-recorder", "true");\n\n  snackbar.dismiss = function () {\n    this.style.opacity = 0;\n  };\n\n  var successIcon = document.createElement("div");\n  successIcon.style = "display: flex; align-items: center; justify-content: center";\n  successIcon.innerHTML = "\\n<svg id=\\"successAnimation\\" data-recorder=\\"true\\" class=\\"animated\\" xmlns=\\"http://www.w3.org/2000/svg\\" width=\\"32\\" height=\\"32\\" viewBox=\\"0 0 70 70\\">\\n  <path id=\\"successAnimationResult\\" data-recorder=\\"true\\" fill=\\"#D8D8D8\\" d=\\"M35,60 C21.1928813,60 10,48.8071187 10,35 C10,21.1928813 21.1928813,10 35,10 C48.8071187,10 60,21.1928813 60,35 C60,48.8071187 48.8071187,60 35,60 Z M23.6332378,33.2260427 L22.3667622,34.7739573 L34.1433655,44.40936 L47.776114,27.6305926 L46.223886,26.3694074 L33.8566345,41.59064 L23.6332378,33.2260427 Z\\"/>\\n  <circle id=\\"successAnimationCircle\\" data-recorder=\\"true\\" cx=\\"35\\" cy=\\"35\\" r=\\"24\\" stroke=\\"#979797\\" stroke-width=\\"2\\" stroke-linecap=\\"round\\" fill=\\"transparent\\"/>\\n  <polyline id=\\"successAnimationCheck\\" data-recorder=\\"true\\" stroke=\\"#979797\\" stroke-width=\\"2\\" points=\\"23 34 34 43 47 27\\" fill=\\"transparent\\"/>\\n</svg>";\n  successIcon.setAttribute("data-recorder", "true");\n  snackbar.appendChild(successIcon);\n  var textSpan = document.createElement("span");\n  textSpan.innerText = message;\n  textSpan.setAttribute("data-recorder", "true");\n  textSpan.style = "margin-right: auto; margin-left: 18px; font-family: Arial, Helvetica, sans-serif; font-weight: 600; font-size: 14px;";\n  snackbar.appendChild(textSpan);\n\n  if (actionText) {\n    if (!action) {\n      action = snackbar.dismiss.bind(snackbar);\n    }\n\n    var actionButton = document.createElement(\'button\');\n    actionButton.className = \'action\';\n    actionButton.innerHTML = actionText;\n    actionButton.setAttribute("data-recorder", "true");\n    actionButton.addEventListener(\'click\', action);\n    snackbar.appendChild(actionButton);\n  }\n\n  setTimeout(function () {\n    if (previous === this) {\n      previous.dismiss();\n    }\n  }.bind(snackbar), 2000);\n  snackbar.addEventListener(\'transitionend\', function (event) {\n    if (event.propertyName === \'opacity\' && this.style.opacity == 0) {\n      this.parentElement.removeChild(this);\n\n      if (previous === this) {\n        previous = null;\n      }\n    }\n  }.bind(snackbar));\n  previous = snackbar;\n  document.body.appendChild(snackbar);\n  getComputedStyle(snackbar).bottom;\n  snackbar.style.bottom = \'-24px\';\n  snackbar.style.opacity = 1;\n}\n\nexports.createSnackBar = createSnackBar;\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9pbmplY3QvdG9hc3QudHM/NjY3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJsZXQgcHJldmlvdXM6IGFueSA9IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTbmFja0JhcihtZXNzYWdlOiBzdHJpbmcsIGFjdGlvblRleHQ6IHN0cmluZywgYWN0aW9uPzogYW55KSB7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgICAgICBwcmV2aW91cy5kaXNtaXNzKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNuYWNrYmFyOiBhbnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgc25hY2tiYXIuY2xhc3NOYW1lID0gJ3BhcGVyLXNuYWNrYmFyJztcbiAgICAgICAgc25hY2tiYXIuc2V0QXR0cmlidXRlKFwiZGF0YS1yZWNvcmRlclwiLCBcInRydWVcIik7XG4gICAgICAgIHNuYWNrYmFyLmRpc21pc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc3R5bGUub3BhY2l0eSA9IDA7XG4gICAgICAgIH07XG4gICAgY29uc3Qgc3VjY2Vzc0ljb246IGFueSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgc3VjY2Vzc0ljb24uc3R5bGUgPSBcImRpc3BsYXk6IGZsZXg7IGFsaWduLWl0ZW1zOiBjZW50ZXI7IGp1c3RpZnktY29udGVudDogY2VudGVyXCI7XG4gICAgc3VjY2Vzc0ljb24uaW5uZXJIVE1MID0gYFxuPHN2ZyBpZD1cInN1Y2Nlc3NBbmltYXRpb25cIiBkYXRhLXJlY29yZGVyPVwidHJ1ZVwiIGNsYXNzPVwiYW5pbWF0ZWRcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIzMlwiIGhlaWdodD1cIjMyXCIgdmlld0JveD1cIjAgMCA3MCA3MFwiPlxuICA8cGF0aCBpZD1cInN1Y2Nlc3NBbmltYXRpb25SZXN1bHRcIiBkYXRhLXJlY29yZGVyPVwidHJ1ZVwiIGZpbGw9XCIjRDhEOEQ4XCIgZD1cIk0zNSw2MCBDMjEuMTkyODgxMyw2MCAxMCw0OC44MDcxMTg3IDEwLDM1IEMxMCwyMS4xOTI4ODEzIDIxLjE5Mjg4MTMsMTAgMzUsMTAgQzQ4LjgwNzExODcsMTAgNjAsMjEuMTkyODgxMyA2MCwzNSBDNjAsNDguODA3MTE4NyA0OC44MDcxMTg3LDYwIDM1LDYwIFogTTIzLjYzMzIzNzgsMzMuMjI2MDQyNyBMMjIuMzY2NzYyMiwzNC43NzM5NTczIEwzNC4xNDMzNjU1LDQ0LjQwOTM2IEw0Ny43NzYxMTQsMjcuNjMwNTkyNiBMNDYuMjIzODg2LDI2LjM2OTQwNzQgTDMzLjg1NjYzNDUsNDEuNTkwNjQgTDIzLjYzMzIzNzgsMzMuMjI2MDQyNyBaXCIvPlxuICA8Y2lyY2xlIGlkPVwic3VjY2Vzc0FuaW1hdGlvbkNpcmNsZVwiIGRhdGEtcmVjb3JkZXI9XCJ0cnVlXCIgY3g9XCIzNVwiIGN5PVwiMzVcIiByPVwiMjRcIiBzdHJva2U9XCIjOTc5Nzk3XCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBmaWxsPVwidHJhbnNwYXJlbnRcIi8+XG4gIDxwb2x5bGluZSBpZD1cInN1Y2Nlc3NBbmltYXRpb25DaGVja1wiIGRhdGEtcmVjb3JkZXI9XCJ0cnVlXCIgc3Ryb2tlPVwiIzk3OTc5N1wiIHN0cm9rZS13aWR0aD1cIjJcIiBwb2ludHM9XCIyMyAzNCAzNCA0MyA0NyAyN1wiIGZpbGw9XCJ0cmFuc3BhcmVudFwiLz5cbjwvc3ZnPmA7XG4gICAgc3VjY2Vzc0ljb24uc2V0QXR0cmlidXRlKFwiZGF0YS1yZWNvcmRlclwiLCBcInRydWVcIik7XG5cbiAgICBzbmFja2Jhci5hcHBlbmRDaGlsZChzdWNjZXNzSWNvbik7XG4gICAgICAgIGxldCB0ZXh0U3BhbjogYW55ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgdGV4dFNwYW4uaW5uZXJUZXh0ID0gbWVzc2FnZTtcbiAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoXCJkYXRhLXJlY29yZGVyXCIsIFwidHJ1ZVwiKTtcbiAgICB0ZXh0U3Bhbi5zdHlsZSA9IFwibWFyZ2luLXJpZ2h0OiBhdXRvOyBtYXJnaW4tbGVmdDogMThweDsgZm9udC1mYW1pbHk6IEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWY7IGZvbnQtd2VpZ2h0OiA2MDA7IGZvbnQtc2l6ZTogMTRweDtcIjtcbiAgICAgICAgc25hY2tiYXIuYXBwZW5kQ2hpbGQodGV4dFNwYW4pO1xuICAgIGlmIChhY3Rpb25UZXh0KSB7XG4gICAgICAgIGlmICghYWN0aW9uKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBzbmFja2Jhci5kaXNtaXNzLmJpbmQoc25hY2tiYXIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhY3Rpb25CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYWN0aW9uQnV0dG9uLmNsYXNzTmFtZSA9ICdhY3Rpb24nO1xuICAgICAgICBhY3Rpb25CdXR0b24uaW5uZXJIVE1MID0gYWN0aW9uVGV4dDtcbiAgICAgICAgYWN0aW9uQnV0dG9uLnNldEF0dHJpYnV0ZShcImRhdGEtcmVjb3JkZXJcIiwgXCJ0cnVlXCIpO1xuICAgICAgICBhY3Rpb25CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBhY3Rpb24pO1xuICAgICAgICBzbmFja2Jhci5hcHBlbmRDaGlsZChhY3Rpb25CdXR0b24pO1xuICAgIH1cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91cyA9PT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzLmRpc21pc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHNuYWNrYmFyKSwgMjAwMCk7XG5cbiAgICAgICAgc25hY2tiYXIuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGZ1bmN0aW9uKGV2ZW50OiBUcmFuc2l0aW9uRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5wcm9wZXJ0eU5hbWUgPT09ICdvcGFjaXR5JyAmJiB0aGlzLnN0eWxlLm9wYWNpdHkgPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmlvdXMgPT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHNuYWNrYmFyKSk7XG5cbiAgICAgICAgcHJldmlvdXMgPSBzbmFja2JhcjtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzbmFja2Jhcik7XG4gICAgICAgIC8vIEluIG9yZGVyIGZvciB0aGUgYW5pbWF0aW9ucyB0byB0cmlnZ2VyLCBJIGhhdmUgdG8gZm9yY2UgdGhlIG9yaWdpbmFsIHN0eWxlIHRvIGJlIGNvbXB1dGVkLCBhbmQgdGhlbiBjaGFuZ2UgaXQuXG4gICAgICAgIGdldENvbXB1dGVkU3R5bGUoc25hY2tiYXIpLmJvdHRvbTtcbiAgICAgICAgc25hY2tiYXIuc3R5bGUuYm90dG9tID0gJy0yNHB4JztcbiAgICAgICAgc25hY2tiYXIuc3R5bGUub3BhY2l0eSA9IDE7XG59O1xuIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQU1BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVEQTtBQTJEQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///19\n')},function(module,exports,__webpack_require__){"use strict";eval('\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError("Generator is already executing.");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nvar __values = (this && this.__values) || function (o) {\n    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;\n    if (m) return m.call(o);\n    return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n};\nObject.defineProperty(exports, "__esModule", { value: true });\nvar cssesc = __webpack_require__(21);\nvar Limit;\n(function (Limit) {\n    Limit[Limit["All"] = 0] = "All";\n    Limit[Limit["Two"] = 1] = "Two";\n    Limit[Limit["One"] = 2] = "One";\n})(Limit || (Limit = {}));\nvar config;\nvar rootDocument;\nfunction default_1(input, options) {\n    if (input.nodeType !== Node.ELEMENT_NODE) {\n        throw new Error("Can\'t generate CSS selector for non-element node type.");\n    }\n    if (\'html\' === input.tagName.toLowerCase()) {\n        return \'html\';\n    }\n    var defaults = {\n        root: document.body,\n        idName: function (name) { return true; },\n        className: function (name) { return true; },\n        tagName: function (name) { return true; },\n        attr: function (name, value) { return false; },\n        seedMinLength: 1,\n        optimizedMinLength: 2,\n        threshold: 1000,\n        maxNumberOfTries: 10000,\n    };\n    config = __assign({}, defaults, options);\n    rootDocument = findRootDocument(config.root, defaults);\n    var path = bottomUpSearch(input, Limit.All, function () {\n        return bottomUpSearch(input, Limit.Two, function () {\n            return bottomUpSearch(input, Limit.One);\n        });\n    });\n    if (path) {\n        var optimized = sort(optimize(path, input));\n        if (optimized.length > 0) {\n            path = optimized[0];\n        }\n        return selector(path);\n    }\n    else {\n        throw new Error("Selector was not found.");\n    }\n}\nexports.default = default_1;\nfunction findRootDocument(rootNode, defaults) {\n    if (rootNode.nodeType === Node.DOCUMENT_NODE) {\n        return rootNode;\n    }\n    if (rootNode === defaults.root) {\n        return rootNode.ownerDocument;\n    }\n    return rootNode;\n}\nfunction bottomUpSearch(input, limit, fallback) {\n    var path = null;\n    var stack = [];\n    var current = input;\n    var i = 0;\n    var _loop_1 = function () {\n        var level = maybe(id(current)) || maybe.apply(void 0, attr(current)) || maybe.apply(void 0, classNames(current)) || maybe(tagName(current)) || [any()];\n        var nth = index(current);\n        if (limit === Limit.All) {\n            if (nth) {\n                level = level.concat(level.filter(dispensableNth).map(function (node) { return nthChild(node, nth); }));\n            }\n        }\n        else if (limit === Limit.Two) {\n            level = level.slice(0, 1);\n            if (nth) {\n                level = level.concat(level.filter(dispensableNth).map(function (node) { return nthChild(node, nth); }));\n            }\n        }\n        else if (limit === Limit.One) {\n            var node = (level = level.slice(0, 1))[0];\n            if (nth && dispensableNth(node)) {\n                level = [nthChild(node, nth)];\n            }\n        }\n        for (var _i = 0, level_1 = level; _i < level_1.length; _i++) {\n            var node = level_1[_i];\n            node.level = i;\n        }\n        stack.push(level);\n        if (stack.length >= config.seedMinLength) {\n            path = findUniquePath(stack, fallback);\n            if (path) {\n                return "break";\n            }\n        }\n        current = current.parentElement;\n        i++;\n    };\n    while (current && current !== config.root.parentElement) {\n        var state_1 = _loop_1();\n        if (state_1 === "break")\n            break;\n    }\n    if (!path) {\n        path = findUniquePath(stack, fallback);\n    }\n    return path;\n}\nfunction findUniquePath(stack, fallback) {\n    var paths = sort(combinations(stack));\n    if (paths.length > config.threshold) {\n        return fallback ? fallback() : null;\n    }\n    for (var _i = 0, paths_1 = paths; _i < paths_1.length; _i++) {\n        var candidate = paths_1[_i];\n        if (unique(candidate)) {\n            return candidate;\n        }\n    }\n    return null;\n}\nfunction selector(path) {\n    var node = path[0];\n    var query = node.name;\n    for (var i = 1; i < path.length; i++) {\n        var level = path[i].level || 0;\n        if (node.level === level - 1) {\n            query = path[i].name + " > " + query;\n        }\n        else {\n            query = path[i].name + " " + query;\n        }\n        node = path[i];\n    }\n    return query;\n}\nfunction penalty(path) {\n    return path.map(function (node) { return node.penalty; }).reduce(function (acc, i) { return acc + i; }, 0);\n}\nfunction unique(path) {\n    switch (rootDocument.querySelectorAll(selector(path)).length) {\n        case 0:\n            throw new Error("Can\'t select any node with this selector: " + selector(path));\n        case 1:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction id(input) {\n    var elementId = input.getAttribute(\'id\');\n    if (elementId && config.idName(elementId)) {\n        return {\n            name: \'#\' + cssesc(elementId, { isIdentifier: true }),\n            penalty: 0,\n        };\n    }\n    return null;\n}\nfunction attr(input) {\n    var attrs = Array.from(input.attributes).filter(function (attr) { return config.attr(attr.name, attr.value); });\n    return attrs.map(function (attr) { return ({\n        name: \'[\' + cssesc(attr.name, { isIdentifier: true }) + \'="\' + cssesc(attr.value) + \'"]\',\n        penalty: 0.5\n    }); });\n}\nfunction classNames(input) {\n    var names = Array.from(input.classList)\n        .filter(config.className);\n    return names.map(function (name) { return ({\n        name: \'.\' + cssesc(name, { isIdentifier: true }),\n        penalty: 1\n    }); });\n}\nfunction tagName(input) {\n    var name = input.tagName.toLowerCase();\n    if (config.tagName(name)) {\n        return {\n            name: name,\n            penalty: 2\n        };\n    }\n    return null;\n}\nfunction any() {\n    return {\n        name: \'*\',\n        penalty: 3\n    };\n}\nfunction index(input) {\n    var parent = input.parentNode;\n    if (!parent) {\n        return null;\n    }\n    var child = parent.firstChild;\n    if (!child) {\n        return null;\n    }\n    var i = 0;\n    while (child) {\n        if (child.nodeType === Node.ELEMENT_NODE) {\n            i++;\n        }\n        if (child === input) {\n            break;\n        }\n        child = child.nextSibling;\n    }\n    return i;\n}\nfunction nthChild(node, i) {\n    return {\n        name: node.name + (":nth-child(" + i + ")"),\n        penalty: node.penalty + 1\n    };\n}\nfunction dispensableNth(node) {\n    return node.name !== \'html\' && !node.name.startsWith(\'#\');\n}\nfunction maybe() {\n    var level = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        level[_i] = arguments[_i];\n    }\n    var list = level.filter(notEmpty);\n    if (list.length > 0) {\n        return list;\n    }\n    return null;\n}\nfunction notEmpty(value) {\n    return value !== null && value !== undefined;\n}\nfunction combinations(stack, path) {\n    var _i, _a, node;\n    if (path === void 0) { path = []; }\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                if (!(stack.length > 0)) return [3 /*break*/, 5];\n                _i = 0, _a = stack[0];\n                _b.label = 1;\n            case 1:\n                if (!(_i < _a.length)) return [3 /*break*/, 4];\n                node = _a[_i];\n                return [5 /*yield**/, __values(combinations(stack.slice(1, stack.length), path.concat(node)))];\n            case 2:\n                _b.sent();\n                _b.label = 3;\n            case 3:\n                _i++;\n                return [3 /*break*/, 1];\n            case 4: return [3 /*break*/, 7];\n            case 5: return [4 /*yield*/, path];\n            case 6:\n                _b.sent();\n                _b.label = 7;\n            case 7: return [2 /*return*/];\n        }\n    });\n}\nfunction sort(paths) {\n    return Array.from(paths).sort(function (a, b) { return penalty(a) - penalty(b); });\n}\nfunction optimize(path, input, scope) {\n    var i, newPath, newPathKey;\n    if (scope === void 0) { scope = { counter: 0, visited: new Map() }; }\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0:\n                if (!(path.length > 2 && path.length > config.optimizedMinLength)) return [3 /*break*/, 5];\n                i = 1;\n                _a.label = 1;\n            case 1:\n                if (!(i < path.length - 1)) return [3 /*break*/, 5];\n                if (scope.counter > config.maxNumberOfTries) {\n                    return [2 /*return*/]; // Okay At least I tried!\n                }\n                scope.counter += 1;\n                newPath = path.slice();\n                newPath.splice(i, 1);\n                newPathKey = selector(newPath);\n                if (scope.visited.has(newPathKey)) {\n                    return [2 /*return*/];\n                }\n                if (!(unique(newPath) && same(newPath, input))) return [3 /*break*/, 4];\n                return [4 /*yield*/, newPath];\n            case 2:\n                _a.sent();\n                scope.visited.set(newPathKey, true);\n                return [5 /*yield**/, __values(optimize(newPath, input, scope))];\n            case 3:\n                _a.sent();\n                _a.label = 4;\n            case 4:\n                i++;\n                return [3 /*break*/, 1];\n            case 5: return [2 /*return*/];\n        }\n    });\n}\nfunction same(path, input) {\n    return rootDocument.querySelector(selector(path)) === input;\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG1lZHYvZmluZGVyL2Rpc3QvaW5kZXguanM/NDgyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgY3NzZXNjID0gcmVxdWlyZShcImNzc2VzY1wiKTtcbnZhciBMaW1pdDtcbihmdW5jdGlvbiAoTGltaXQpIHtcbiAgICBMaW1pdFtMaW1pdFtcIkFsbFwiXSA9IDBdID0gXCJBbGxcIjtcbiAgICBMaW1pdFtMaW1pdFtcIlR3b1wiXSA9IDFdID0gXCJUd29cIjtcbiAgICBMaW1pdFtMaW1pdFtcIk9uZVwiXSA9IDJdID0gXCJPbmVcIjtcbn0pKExpbWl0IHx8IChMaW1pdCA9IHt9KSk7XG52YXIgY29uZmlnO1xudmFyIHJvb3REb2N1bWVudDtcbmZ1bmN0aW9uIGRlZmF1bHRfMShpbnB1dCwgb3B0aW9ucykge1xuICAgIGlmIChpbnB1dC5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZ2VuZXJhdGUgQ1NTIHNlbGVjdG9yIGZvciBub24tZWxlbWVudCBub2RlIHR5cGUuXCIpO1xuICAgIH1cbiAgICBpZiAoJ2h0bWwnID09PSBpbnB1dC50YWdOYW1lLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgcmV0dXJuICdodG1sJztcbiAgICB9XG4gICAgdmFyIGRlZmF1bHRzID0ge1xuICAgICAgICByb290OiBkb2N1bWVudC5ib2R5LFxuICAgICAgICBpZE5hbWU6IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICBjbGFzc05hbWU6IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiB0cnVlOyB9LFxuICAgICAgICB0YWdOYW1lOiBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgYXR0cjogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgc2VlZE1pbkxlbmd0aDogMSxcbiAgICAgICAgb3B0aW1pemVkTWluTGVuZ3RoOiAyLFxuICAgICAgICB0aHJlc2hvbGQ6IDEwMDAsXG4gICAgICAgIG1heE51bWJlck9mVHJpZXM6IDEwMDAwLFxuICAgIH07XG4gICAgY29uZmlnID0gX19hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICByb290RG9jdW1lbnQgPSBmaW5kUm9vdERvY3VtZW50KGNvbmZpZy5yb290LCBkZWZhdWx0cyk7XG4gICAgdmFyIHBhdGggPSBib3R0b21VcFNlYXJjaChpbnB1dCwgTGltaXQuQWxsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBib3R0b21VcFNlYXJjaChpbnB1dCwgTGltaXQuVHdvLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYm90dG9tVXBTZWFyY2goaW5wdXQsIExpbWl0Lk9uZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChwYXRoKSB7XG4gICAgICAgIHZhciBvcHRpbWl6ZWQgPSBzb3J0KG9wdGltaXplKHBhdGgsIGlucHV0KSk7XG4gICAgICAgIGlmIChvcHRpbWl6ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcGF0aCA9IG9wdGltaXplZFswXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VsZWN0b3IocGF0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZWxlY3RvciB3YXMgbm90IGZvdW5kLlwiKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG5mdW5jdGlvbiBmaW5kUm9vdERvY3VtZW50KHJvb3ROb2RlLCBkZWZhdWx0cykge1xuICAgIGlmIChyb290Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICAgIHJldHVybiByb290Tm9kZTtcbiAgICB9XG4gICAgaWYgKHJvb3ROb2RlID09PSBkZWZhdWx0cy5yb290KSB7XG4gICAgICAgIHJldHVybiByb290Tm9kZS5vd25lckRvY3VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gcm9vdE5vZGU7XG59XG5mdW5jdGlvbiBib3R0b21VcFNlYXJjaChpbnB1dCwgbGltaXQsIGZhbGxiYWNrKSB7XG4gICAgdmFyIHBhdGggPSBudWxsO1xuICAgIHZhciBzdGFjayA9IFtdO1xuICAgIHZhciBjdXJyZW50ID0gaW5wdXQ7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGV2ZWwgPSBtYXliZShpZChjdXJyZW50KSkgfHwgbWF5YmUuYXBwbHkodm9pZCAwLCBhdHRyKGN1cnJlbnQpKSB8fCBtYXliZS5hcHBseSh2b2lkIDAsIGNsYXNzTmFtZXMoY3VycmVudCkpIHx8IG1heWJlKHRhZ05hbWUoY3VycmVudCkpIHx8IFthbnkoKV07XG4gICAgICAgIHZhciBudGggPSBpbmRleChjdXJyZW50KTtcbiAgICAgICAgaWYgKGxpbWl0ID09PSBMaW1pdC5BbGwpIHtcbiAgICAgICAgICAgIGlmIChudGgpIHtcbiAgICAgICAgICAgICAgICBsZXZlbCA9IGxldmVsLmNvbmNhdChsZXZlbC5maWx0ZXIoZGlzcGVuc2FibGVOdGgpLm1hcChmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gbnRoQ2hpbGQobm9kZSwgbnRoKTsgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxpbWl0ID09PSBMaW1pdC5Ud28pIHtcbiAgICAgICAgICAgIGxldmVsID0gbGV2ZWwuc2xpY2UoMCwgMSk7XG4gICAgICAgICAgICBpZiAobnRoKSB7XG4gICAgICAgICAgICAgICAgbGV2ZWwgPSBsZXZlbC5jb25jYXQobGV2ZWwuZmlsdGVyKGRpc3BlbnNhYmxlTnRoKS5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG50aENoaWxkKG5vZGUsIG50aCk7IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaW1pdCA9PT0gTGltaXQuT25lKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IChsZXZlbCA9IGxldmVsLnNsaWNlKDAsIDEpKVswXTtcbiAgICAgICAgICAgIGlmIChudGggJiYgZGlzcGVuc2FibGVOdGgobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBsZXZlbCA9IFtudGhDaGlsZChub2RlLCBudGgpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGxldmVsXzEgPSBsZXZlbDsgX2kgPCBsZXZlbF8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBsZXZlbF8xW19pXTtcbiAgICAgICAgICAgIG5vZGUubGV2ZWwgPSBpO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrLnB1c2gobGV2ZWwpO1xuICAgICAgICBpZiAoc3RhY2subGVuZ3RoID49IGNvbmZpZy5zZWVkTWluTGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXRoID0gZmluZFVuaXF1ZVBhdGgoc3RhY2ssIGZhbGxiYWNrKTtcbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBpKys7XG4gICAgfTtcbiAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBjb25maWcucm9vdC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgIHZhciBzdGF0ZV8xID0gX2xvb3BfMSgpO1xuICAgICAgICBpZiAoc3RhdGVfMSA9PT0gXCJicmVha1wiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghcGF0aCkge1xuICAgICAgICBwYXRoID0gZmluZFVuaXF1ZVBhdGgoc3RhY2ssIGZhbGxiYWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5mdW5jdGlvbiBmaW5kVW5pcXVlUGF0aChzdGFjaywgZmFsbGJhY2spIHtcbiAgICB2YXIgcGF0aHMgPSBzb3J0KGNvbWJpbmF0aW9ucyhzdGFjaykpO1xuICAgIGlmIChwYXRocy5sZW5ndGggPiBjb25maWcudGhyZXNob2xkKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFjayA/IGZhbGxiYWNrKCkgOiBudWxsO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIHBhdGhzXzEgPSBwYXRoczsgX2kgPCBwYXRoc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY2FuZGlkYXRlID0gcGF0aHNfMVtfaV07XG4gICAgICAgIGlmICh1bmlxdWUoY2FuZGlkYXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNlbGVjdG9yKHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHBhdGhbMF07XG4gICAgdmFyIHF1ZXJ5ID0gbm9kZS5uYW1lO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGV2ZWwgPSBwYXRoW2ldLmxldmVsIHx8IDA7XG4gICAgICAgIGlmIChub2RlLmxldmVsID09PSBsZXZlbCAtIDEpIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gcGF0aFtpXS5uYW1lICsgXCIgPiBcIiArIHF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcXVlcnkgPSBwYXRoW2ldLm5hbWUgKyBcIiBcIiArIHF1ZXJ5O1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBwYXRoW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG59XG5mdW5jdGlvbiBwZW5hbHR5KHBhdGgpIHtcbiAgICByZXR1cm4gcGF0aC5tYXAoZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGUucGVuYWx0eTsgfSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGkpIHsgcmV0dXJuIGFjYyArIGk7IH0sIDApO1xufVxuZnVuY3Rpb24gdW5pcXVlKHBhdGgpIHtcbiAgICBzd2l0Y2ggKHJvb3REb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKHBhdGgpKS5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc2VsZWN0IGFueSBub2RlIHdpdGggdGhpcyBzZWxlY3RvcjogXCIgKyBzZWxlY3RvcihwYXRoKSk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlkKGlucHV0KSB7XG4gICAgdmFyIGVsZW1lbnRJZCA9IGlucHV0LmdldEF0dHJpYnV0ZSgnaWQnKTtcbiAgICBpZiAoZWxlbWVudElkICYmIGNvbmZpZy5pZE5hbWUoZWxlbWVudElkKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogJyMnICsgY3NzZXNjKGVsZW1lbnRJZCwgeyBpc0lkZW50aWZpZXI6IHRydWUgfSksXG4gICAgICAgICAgICBwZW5hbHR5OiAwLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGF0dHIoaW5wdXQpIHtcbiAgICB2YXIgYXR0cnMgPSBBcnJheS5mcm9tKGlucHV0LmF0dHJpYnV0ZXMpLmZpbHRlcihmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gY29uZmlnLmF0dHIoYXR0ci5uYW1lLCBhdHRyLnZhbHVlKTsgfSk7XG4gICAgcmV0dXJuIGF0dHJzLm1hcChmdW5jdGlvbiAoYXR0cikgeyByZXR1cm4gKHtcbiAgICAgICAgbmFtZTogJ1snICsgY3NzZXNjKGF0dHIubmFtZSwgeyBpc0lkZW50aWZpZXI6IHRydWUgfSkgKyAnPVwiJyArIGNzc2VzYyhhdHRyLnZhbHVlKSArICdcIl0nLFxuICAgICAgICBwZW5hbHR5OiAwLjVcbiAgICB9KTsgfSk7XG59XG5mdW5jdGlvbiBjbGFzc05hbWVzKGlucHV0KSB7XG4gICAgdmFyIG5hbWVzID0gQXJyYXkuZnJvbShpbnB1dC5jbGFzc0xpc3QpXG4gICAgICAgIC5maWx0ZXIoY29uZmlnLmNsYXNzTmFtZSk7XG4gICAgcmV0dXJuIG5hbWVzLm1hcChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gKHtcbiAgICAgICAgbmFtZTogJy4nICsgY3NzZXNjKG5hbWUsIHsgaXNJZGVudGlmaWVyOiB0cnVlIH0pLFxuICAgICAgICBwZW5hbHR5OiAxXG4gICAgfSk7IH0pO1xufVxuZnVuY3Rpb24gdGFnTmFtZShpbnB1dCkge1xuICAgIHZhciBuYW1lID0gaW5wdXQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChjb25maWcudGFnTmFtZShuYW1lKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHBlbmFsdHk6IDJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBhbnkoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJyonLFxuICAgICAgICBwZW5hbHR5OiAzXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluZGV4KGlucHV0KSB7XG4gICAgdmFyIHBhcmVudCA9IGlucHV0LnBhcmVudE5vZGU7XG4gICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZCA9IHBhcmVudC5maXJzdENoaWxkO1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCA9PT0gaW5wdXQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuZnVuY3Rpb24gbnRoQ2hpbGQobm9kZSwgaSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5vZGUubmFtZSArIChcIjpudGgtY2hpbGQoXCIgKyBpICsgXCIpXCIpLFxuICAgICAgICBwZW5hbHR5OiBub2RlLnBlbmFsdHkgKyAxXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGRpc3BlbnNhYmxlTnRoKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lICE9PSAnaHRtbCcgJiYgIW5vZGUubmFtZS5zdGFydHNXaXRoKCcjJyk7XG59XG5mdW5jdGlvbiBtYXliZSgpIHtcbiAgICB2YXIgbGV2ZWwgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBsZXZlbFtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgbGlzdCA9IGxldmVsLmZpbHRlcihub3RFbXB0eSk7XG4gICAgaWYgKGxpc3QubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBub3RFbXB0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gY29tYmluYXRpb25zKHN0YWNrLCBwYXRoKSB7XG4gICAgdmFyIF9pLCBfYSwgbm9kZTtcbiAgICBpZiAocGF0aCA9PT0gdm9pZCAwKSB7IHBhdGggPSBbXTsgfVxuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghKHN0YWNrLmxlbmd0aCA+IDApKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICBfaSA9IDAsIF9hID0gc3RhY2tbMF07XG4gICAgICAgICAgICAgICAgX2IubGFiZWwgPSAxO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmICghKF9pIDwgX2EubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgbm9kZSA9IF9hW19pXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzUgLyp5aWVsZCoqLywgX192YWx1ZXMoY29tYmluYXRpb25zKHN0YWNrLnNsaWNlKDEsIHN0YWNrLmxlbmd0aCksIHBhdGguY29uY2F0KG5vZGUpKSldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDM7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcbiAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFszIC8qYnJlYWsqLywgN107XG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbNCAvKnlpZWxkKi8sIHBhdGhdO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDc7XG4gICAgICAgICAgICBjYXNlIDc6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc29ydChwYXRocykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHBhdGhzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBwZW5hbHR5KGEpIC0gcGVuYWx0eShiKTsgfSk7XG59XG5mdW5jdGlvbiBvcHRpbWl6ZShwYXRoLCBpbnB1dCwgc2NvcGUpIHtcbiAgICB2YXIgaSwgbmV3UGF0aCwgbmV3UGF0aEtleTtcbiAgICBpZiAoc2NvcGUgPT09IHZvaWQgMCkgeyBzY29wZSA9IHsgY291bnRlcjogMCwgdmlzaXRlZDogbmV3IE1hcCgpIH07IH1cbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIShwYXRoLmxlbmd0aCA+IDIgJiYgcGF0aC5sZW5ndGggPiBjb25maWcub3B0aW1pemVkTWluTGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XG4gICAgICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGlmICghKGkgPCBwYXRoLmxlbmd0aCAtIDEpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcbiAgICAgICAgICAgICAgICBpZiAoc2NvcGUuY291bnRlciA+IGNvbmZpZy5tYXhOdW1iZXJPZlRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTsgLy8gT2theSBBdCBsZWFzdCBJIHRyaWVkIVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY29wZS5jb3VudGVyICs9IDE7XG4gICAgICAgICAgICAgICAgbmV3UGF0aCA9IHBhdGguc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBuZXdQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICBuZXdQYXRoS2V5ID0gc2VsZWN0b3IobmV3UGF0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHNjb3BlLnZpc2l0ZWQuaGFzKG5ld1BhdGhLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEodW5pcXVlKG5ld1BhdGgpICYmIHNhbWUobmV3UGF0aCwgaW5wdXQpKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3UGF0aF07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIHNjb3BlLnZpc2l0ZWQuc2V0KG5ld1BhdGhLZXksIHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNSAvKnlpZWxkKiovLCBfX3ZhbHVlcyhvcHRpbWl6ZShuZXdQYXRoLCBpbnB1dCwgc2NvcGUpKV07XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2FtZShwYXRoLCBpbnB1dCkge1xuICAgIHJldHVybiByb290RG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcihwYXRoKSkgPT09IGlucHV0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n')},function(module,exports,__webpack_require__){"use strict";eval("/*! https://mths.be/cssesc v1.0.1 by @mathias */\n\n\nvar object = {};\nvar hasOwnProperty = object.hasOwnProperty;\nvar merge = function merge(options, defaults) {\n\tif (!options) {\n\t\treturn defaults;\n\t}\n\tvar result = {};\n\tfor (var key in defaults) {\n\t\t// `if (defaults.hasOwnProperty(key) { … }` is not needed here, since\n\t\t// only recognized option names are used.\n\t\tresult[key] = hasOwnProperty.call(options, key) ? options[key] : defaults[key];\n\t}\n\treturn result;\n};\n\nvar regexAnySingleEscape = /[ -,\\.\\/;-@\\[-\\^`\\{-~]/;\nvar regexSingleEscape = /[ -,\\.\\/;-@\\[\\]\\^`\\{-~]/;\nvar regexAlwaysEscape = /['\"\\\\]/;\nvar regexExcessiveSpaces = /(^|\\\\+)?(\\\\[A-F0-9]{1,6})\\x20(?![a-fA-F0-9\\x20])/g;\n\n// https://mathiasbynens.be/notes/css-escapes#css\nvar cssesc = function cssesc(string, options) {\n\toptions = merge(options, cssesc.options);\n\tif (options.quotes != 'single' && options.quotes != 'double') {\n\t\toptions.quotes = 'single';\n\t}\n\tvar quote = options.quotes == 'double' ? '\"' : '\\'';\n\tvar isIdentifier = options.isIdentifier;\n\n\tvar firstChar = string.charAt(0);\n\tvar output = '';\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar character = string.charAt(counter++);\n\t\tvar codePoint = character.charCodeAt();\n\t\tvar value = void 0;\n\t\t// If it’s not a printable ASCII character…\n\t\tif (codePoint < 0x20 || codePoint > 0x7E) {\n\t\t\tif (codePoint >= 0xD800 && codePoint <= 0xDBFF && counter < length) {\n\t\t\t\t// It’s a high surrogate, and there is a next character.\n\t\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t\t// next character is low surrogate\n\t\t\t\t\tcodePoint = ((codePoint & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000;\n\t\t\t\t} else {\n\t\t\t\t\t// It’s an unmatched surrogate; only append this code unit, in case\n\t\t\t\t\t// the next code unit is the high surrogate of a surrogate pair.\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t} else {\n\t\t\tif (options.escapeEverything) {\n\t\t\t\tif (regexAnySingleEscape.test(character)) {\n\t\t\t\t\tvalue = '\\\\' + character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t\t// Note: `:` could be escaped as `\\:`, but that fails in IE < 8.\n\t\t\t} else if (/[\\t\\n\\f\\r\\x0B:]/.test(character)) {\n\t\t\t\tif (!isIdentifier && character == ':') {\n\t\t\t\t\tvalue = character;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = '\\\\' + codePoint.toString(16).toUpperCase() + ' ';\n\t\t\t\t}\n\t\t\t} else if (character == '\\\\' || !isIdentifier && (character == '\"' && quote == character || character == '\\'' && quote == character) || isIdentifier && regexSingleEscape.test(character)) {\n\t\t\t\tvalue = '\\\\' + character;\n\t\t\t} else {\n\t\t\t\tvalue = character;\n\t\t\t}\n\t\t}\n\t\toutput += value;\n\t}\n\n\tif (isIdentifier) {\n\t\tif (/^_/.test(output)) {\n\t\t\t// Prevent IE6 from ignoring the rule altogether (in case this is for an\n\t\t\t// identifier used as a selector)\n\t\t\toutput = '\\\\_' + output.slice(1);\n\t\t} else if (/^-[-\\d]/.test(output)) {\n\t\t\toutput = '\\\\-' + output.slice(1);\n\t\t} else if (/\\d/.test(firstChar)) {\n\t\t\toutput = '\\\\3' + firstChar + ' ' + output.slice(1);\n\t\t}\n\t}\n\n\t// Remove spaces after `\\HEX` escapes that are not followed by a hex digit,\n\t// since they’re redundant. Note that this is only possible if the escape\n\t// sequence isn’t preceded by an odd number of backslashes.\n\toutput = output.replace(regexExcessiveSpaces, function ($0, $1, $2) {\n\t\tif ($1 && $1.length % 2) {\n\t\t\t// It’s not safe to remove the space, so don’t.\n\t\t\treturn $0;\n\t\t}\n\t\t// Strip the space.\n\t\treturn ($1 || '') + $2;\n\t});\n\n\tif (!isIdentifier && options.wrap) {\n\t\treturn quote + output + quote;\n\t}\n\treturn output;\n};\n\n// Expose default options (so they can be overridden globally).\ncssesc.options = {\n\t'escapeEverything': false,\n\t'isIdentifier': false,\n\t'quotes': 'single',\n\t'wrap': false\n};\n\ncssesc.version = '1.0.1';\n\nmodule.exports = cssesc;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY3NzZXNjL2Nzc2VzYy5qcz8wYjhhIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBodHRwczovL210aHMuYmUvY3NzZXNjIHYxLjAuMSBieSBAbWF0aGlhcyAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgb2JqZWN0ID0ge307XG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG52YXIgbWVyZ2UgPSBmdW5jdGlvbiBtZXJnZShvcHRpb25zLCBkZWZhdWx0cykge1xuXHRpZiAoIW9wdGlvbnMpIHtcblx0XHRyZXR1cm4gZGVmYXVsdHM7XG5cdH1cblx0dmFyIHJlc3VsdCA9IHt9O1xuXHRmb3IgKHZhciBrZXkgaW4gZGVmYXVsdHMpIHtcblx0XHQvLyBgaWYgKGRlZmF1bHRzLmhhc093blByb3BlcnR5KGtleSkgeyDigKYgfWAgaXMgbm90IG5lZWRlZCBoZXJlLCBzaW5jZVxuXHRcdC8vIG9ubHkgcmVjb2duaXplZCBvcHRpb24gbmFtZXMgYXJlIHVzZWQuXG5cdFx0cmVzdWx0W2tleV0gPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIGtleSkgPyBvcHRpb25zW2tleV0gOiBkZWZhdWx0c1trZXldO1xuXHR9XG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG52YXIgcmVnZXhBbnlTaW5nbGVFc2NhcGUgPSAvWyAtLFxcLlxcLzstQFxcWy1cXF5gXFx7LX5dLztcbnZhciByZWdleFNpbmdsZUVzY2FwZSA9IC9bIC0sXFwuXFwvOy1AXFxbXFxdXFxeYFxcey1+XS87XG52YXIgcmVnZXhBbHdheXNFc2NhcGUgPSAvWydcIlxcXFxdLztcbnZhciByZWdleEV4Y2Vzc2l2ZVNwYWNlcyA9IC8oXnxcXFxcKyk/KFxcXFxbQS1GMC05XXsxLDZ9KVxceDIwKD8hW2EtZkEtRjAtOVxceDIwXSkvZztcblxuLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2Nzcy1lc2NhcGVzI2Nzc1xudmFyIGNzc2VzYyA9IGZ1bmN0aW9uIGNzc2VzYyhzdHJpbmcsIG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIGNzc2VzYy5vcHRpb25zKTtcblx0aWYgKG9wdGlvbnMucXVvdGVzICE9ICdzaW5nbGUnICYmIG9wdGlvbnMucXVvdGVzICE9ICdkb3VibGUnKSB7XG5cdFx0b3B0aW9ucy5xdW90ZXMgPSAnc2luZ2xlJztcblx0fVxuXHR2YXIgcXVvdGUgPSBvcHRpb25zLnF1b3RlcyA9PSAnZG91YmxlJyA/ICdcIicgOiAnXFwnJztcblx0dmFyIGlzSWRlbnRpZmllciA9IG9wdGlvbnMuaXNJZGVudGlmaWVyO1xuXG5cdHZhciBmaXJzdENoYXIgPSBzdHJpbmcuY2hhckF0KDApO1xuXHR2YXIgb3V0cHV0ID0gJyc7XG5cdHZhciBjb3VudGVyID0gMDtcblx0dmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG5cdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0dmFyIGNoYXJhY3RlciA9IHN0cmluZy5jaGFyQXQoY291bnRlcisrKTtcblx0XHR2YXIgY29kZVBvaW50ID0gY2hhcmFjdGVyLmNoYXJDb2RlQXQoKTtcblx0XHR2YXIgdmFsdWUgPSB2b2lkIDA7XG5cdFx0Ly8gSWYgaXTigJlzIG5vdCBhIHByaW50YWJsZSBBU0NJSSBjaGFyYWN0ZXLigKZcblx0XHRpZiAoY29kZVBvaW50IDwgMHgyMCB8fCBjb2RlUG9pbnQgPiAweDdFKSB7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gSXTigJlzIGEgaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyLlxuXHRcdFx0XHR2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHtcblx0XHRcdFx0XHQvLyBuZXh0IGNoYXJhY3RlciBpcyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0Y29kZVBvaW50ID0gKChjb2RlUG9pbnQgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBJdOKAmXMgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2Vcblx0XHRcdFx0XHQvLyB0aGUgbmV4dCBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXIuXG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9ICdcXFxcJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArICcgJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKG9wdGlvbnMuZXNjYXBlRXZlcnl0aGluZykge1xuXHRcdFx0XHRpZiAocmVnZXhBbnlTaW5nbGVFc2NhcGUudGVzdChjaGFyYWN0ZXIpKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSAnXFxcXCcgKyBjaGFyYWN0ZXI7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFsdWUgPSAnXFxcXCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyAnICc7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gTm90ZTogYDpgIGNvdWxkIGJlIGVzY2FwZWQgYXMgYFxcOmAsIGJ1dCB0aGF0IGZhaWxzIGluIElFIDwgOC5cblx0XHRcdH0gZWxzZSBpZiAoL1tcXHRcXG5cXGZcXHJcXHgwQjpdLy50ZXN0KGNoYXJhY3RlcikpIHtcblx0XHRcdFx0aWYgKCFpc0lkZW50aWZpZXIgJiYgY2hhcmFjdGVyID09ICc6Jykge1xuXHRcdFx0XHRcdHZhbHVlID0gY2hhcmFjdGVyO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gJ1xcXFwnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgJyAnO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGNoYXJhY3RlciA9PSAnXFxcXCcgfHwgIWlzSWRlbnRpZmllciAmJiAoY2hhcmFjdGVyID09ICdcIicgJiYgcXVvdGUgPT0gY2hhcmFjdGVyIHx8IGNoYXJhY3RlciA9PSAnXFwnJyAmJiBxdW90ZSA9PSBjaGFyYWN0ZXIpIHx8IGlzSWRlbnRpZmllciAmJiByZWdleFNpbmdsZUVzY2FwZS50ZXN0KGNoYXJhY3RlcikpIHtcblx0XHRcdFx0dmFsdWUgPSAnXFxcXCcgKyBjaGFyYWN0ZXI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZSA9IGNoYXJhY3Rlcjtcblx0XHRcdH1cblx0XHR9XG5cdFx0b3V0cHV0ICs9IHZhbHVlO1xuXHR9XG5cblx0aWYgKGlzSWRlbnRpZmllcikge1xuXHRcdGlmICgvXl8vLnRlc3Qob3V0cHV0KSkge1xuXHRcdFx0Ly8gUHJldmVudCBJRTYgZnJvbSBpZ25vcmluZyB0aGUgcnVsZSBhbHRvZ2V0aGVyIChpbiBjYXNlIHRoaXMgaXMgZm9yIGFuXG5cdFx0XHQvLyBpZGVudGlmaWVyIHVzZWQgYXMgYSBzZWxlY3Rvcilcblx0XHRcdG91dHB1dCA9ICdcXFxcXycgKyBvdXRwdXQuc2xpY2UoMSk7XG5cdFx0fSBlbHNlIGlmICgvXi1bLVxcZF0vLnRlc3Qob3V0cHV0KSkge1xuXHRcdFx0b3V0cHV0ID0gJ1xcXFwtJyArIG91dHB1dC5zbGljZSgxKTtcblx0XHR9IGVsc2UgaWYgKC9cXGQvLnRlc3QoZmlyc3RDaGFyKSkge1xuXHRcdFx0b3V0cHV0ID0gJ1xcXFwzJyArIGZpcnN0Q2hhciArICcgJyArIG91dHB1dC5zbGljZSgxKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZW1vdmUgc3BhY2VzIGFmdGVyIGBcXEhFWGAgZXNjYXBlcyB0aGF0IGFyZSBub3QgZm9sbG93ZWQgYnkgYSBoZXggZGlnaXQsXG5cdC8vIHNpbmNlIHRoZXnigJlyZSByZWR1bmRhbnQuIE5vdGUgdGhhdCB0aGlzIGlzIG9ubHkgcG9zc2libGUgaWYgdGhlIGVzY2FwZVxuXHQvLyBzZXF1ZW5jZSBpc27igJl0IHByZWNlZGVkIGJ5IGFuIG9kZCBudW1iZXIgb2YgYmFja3NsYXNoZXMuXG5cdG91dHB1dCA9IG91dHB1dC5yZXBsYWNlKHJlZ2V4RXhjZXNzaXZlU3BhY2VzLCBmdW5jdGlvbiAoJDAsICQxLCAkMikge1xuXHRcdGlmICgkMSAmJiAkMS5sZW5ndGggJSAyKSB7XG5cdFx0XHQvLyBJdOKAmXMgbm90IHNhZmUgdG8gcmVtb3ZlIHRoZSBzcGFjZSwgc28gZG9u4oCZdC5cblx0XHRcdHJldHVybiAkMDtcblx0XHR9XG5cdFx0Ly8gU3RyaXAgdGhlIHNwYWNlLlxuXHRcdHJldHVybiAoJDEgfHwgJycpICsgJDI7XG5cdH0pO1xuXG5cdGlmICghaXNJZGVudGlmaWVyICYmIG9wdGlvbnMud3JhcCkge1xuXHRcdHJldHVybiBxdW90ZSArIG91dHB1dCArIHF1b3RlO1xuXHR9XG5cdHJldHVybiBvdXRwdXQ7XG59O1xuXG4vLyBFeHBvc2UgZGVmYXVsdCBvcHRpb25zIChzbyB0aGV5IGNhbiBiZSBvdmVycmlkZGVuIGdsb2JhbGx5KS5cbmNzc2VzYy5vcHRpb25zID0ge1xuXHQnZXNjYXBlRXZlcnl0aGluZyc6IGZhbHNlLFxuXHQnaXNJZGVudGlmaWVyJzogZmFsc2UsXG5cdCdxdW90ZXMnOiAnc2luZ2xlJyxcblx0J3dyYXAnOiBmYWxzZVxufTtcblxuY3NzZXNjLnZlcnNpb24gPSAnMS4wLjEnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNzc2VzYztcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///21\n")},function(module,exports,__webpack_require__){"use strict";eval('\n\nObject.defineProperty(exports, "__esModule", {\n  value: true\n});\n\nvar dom_1 = __webpack_require__(7);\n\nvar DOMEventsToRecord_1 = __webpack_require__(5);\n\nvar constants_1 = __webpack_require__(2);\n\nvar FormWizard = function () {\n  function FormWizard(recordingOverlay, eventsController) {\n    this.state = {\n      isInvalidScript: false\n    };\n    this.recordingOverlay = recordingOverlay;\n    this.eventsController = eventsController;\n    this.evaluateValidationScript = this.evaluateValidationScript.bind(this);\n    this.handleSaveExtractForm = this.handleSaveExtractForm.bind(this);\n    this.evaluteAssertText = this.evaluteAssertText.bind(this);\n    this.handleSaveAssertForm = this.handleSaveAssertForm.bind(this);\n  }\n\n  FormWizard.prototype.initNodes = function () {\n    this._modalHeading = document.querySelector(".overlay_heading_container .overlay_heading");\n    this._modalContentContainer = document.querySelector(".overlay_modal_content");\n    this._extract_event_form = document.querySelector("#extract_event_form");\n    this._assertEventForm = document.querySelector("#assert_event_form");\n    this._validationScriptTextArea = document.querySelector("#validation_script");\n    this._assertComparisionText = document.querySelector("#assert_comparision_text");\n    this._assertValidation = document.querySelector("#assert_validation");\n    this._validationScript = document.querySelector("#extract_event_form #validation_script");\n    this._extractedInfoPreview = document.querySelector("#extract_event_form #extracted_info_preview");\n    this._extractVariableName = document.querySelector("#extract_variable_name");\n    this._submitExtractForm = document.querySelector("#submit_extract_form");\n    this._submitAssertForm = document.querySelector("#submit_assert_form");\n  };\n\n  FormWizard.prototype.evaluateValidationScript = function () {\n    try {\n      var targetElement = this.recordingOverlay.getState().targetElement;\n      var escapedHTML = targetElement.innerHTML.toString().replace(/\\`/g, "\\\\`").trim();\n      var escapedText = targetElement.innerText.replace(/\\`/g, "\\\\`").trim();\n      var script = "(" + this._validationScript.value + ")(" + \'`\' + escapedHTML + \'`\' + ", " + \'`\' + ("" + escapedText) + \'`\' + ")";\n      var output = eval(script);\n      this._extractedInfoPreview.value = output;\n      this._extractedInfoPreview.style = "";\n      this._validationScriptTextArea.style = "";\n      this.state.invalid = false;\n    } catch (_a) {\n      this._extractedInfoPreview.style = "border: 1px solid red;";\n      this._validationScriptTextArea.style = "border: 1px solid red;";\n      this.state.invalid = true;\n    }\n  };\n\n  FormWizard.prototype.handleSaveExtractForm = function () {\n    var _a;\n\n    var variableName = this._extractVariableName.value;\n    var scriptContent = this._validationScript.value;\n    var isInvalidScript = this.state.isInvalidScript;\n    var targetElement = this.recordingOverlay.getState().targetElement;\n\n    if (!isInvalidScript && variableName && scriptContent) {\n      var payload = (_a = {}, _a[variableName] = scriptContent, _a);\n      this.eventsController.saveCapturedEventInBackground(DOMEventsToRecord_1.EXTRACT_INFO, targetElement, payload);\n      this.recordingOverlay.toggleEventsBox();\n    } else {\n      console.log(isInvalidScript, variableName, scriptContent);\n    }\n  };\n\n  FormWizard.prototype.handleSaveAssertForm = function () {\n    var comparisionText = this._assertComparisionText.value;\n    var targetElement = this.recordingOverlay.getState().targetElement;\n    this.eventsController.saveCapturedEventInBackground(DOMEventsToRecord_1.ASSERT_TEXT, targetElement, comparisionText);\n    this.recordingOverlay.toggleEventsBox();\n  };\n\n  FormWizard.prototype.initEventListener = function () {\n    this._validationScript.addEventListener("keyup", this.evaluateValidationScript);\n\n    this._submitExtractForm.addEventListener("click", this.handleSaveExtractForm);\n\n    this._assertComparisionText.addEventListener("keyup", this.evaluteAssertText);\n\n    this._submitAssertForm.addEventListener("click", this.handleSaveAssertForm);\n  };\n\n  FormWizard.prototype.evaluteAssertText = function () {\n    var targetElement = this.recordingOverlay.getState().targetElement;\n\n    if (targetElement && targetElement.innerText === this._assertComparisionText.value) {\n      this._assertValidation.value = "TRUE";\n    } else {\n      this._assertValidation.value = "FALSE";\n    }\n  };\n\n  FormWizard.prototype.resetExtractFields = function () {\n    this._extractVariableName.value = "";\n    this._validationScript.value = constants_1.DEFAULT_VALIDATION_SCRIPT;\n    this._extractedInfoPreview.value = "";\n  };\n\n  FormWizard.prototype.initAssertFields = function () {\n    var targetElement = this.recordingOverlay.getState().targetElement;\n    this._assertComparisionText.value = targetElement.innerText;\n  };\n\n  FormWizard.prototype.renderForm = function () {\n    switch (this.actionType) {\n      case DOMEventsToRecord_1.EXTRACT_INFO:\n        this.resetExtractFields();\n        this._modalHeading.innerHTML = "Extract Info Form";\n\n        this._extract_event_form.removeAttribute("data-gone");\n\n        this.evaluateValidationScript();\n        break;\n\n      case DOMEventsToRecord_1.ASSERT_TEXT:\n        this.initAssertFields();\n        this._modalHeading.innerHTML = "Assert Text";\n\n        this._assertEventForm.removeAttribute("data-gone");\n\n        this.evaluteAssertText();\n        break;\n    }\n  };\n\n  FormWizard.prototype.boot = function (actionType) {\n    console.debug("Form wizard booted up");\n    this.initNodes();\n    this.initEventListener();\n    this.actionType = actionType;\n    dom_1.setAttributeForAllChildNodes(this._modalContentContainer, "data-gone", "true");\n    this.renderForm();\n  };\n\n  return FormWizard;\n}();\n\nexports["default"] = FormWizard;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc2NyaXB0cy9pbmplY3QvdWkvZm9ybVdpemFyZC50cz8zNzM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWNvcmRpbmdPdmVybGF5IGZyb20gXCIuL3JlY29yZGluZ092ZXJsYXlcIjtcbmltcG9ydCB7c2V0QXR0cmlidXRlRm9yQWxsQ2hpbGROb2Rlc30gZnJvbSBcIi4uLy4uLy4uL3V0aWxzL2RvbVwiO1xuaW1wb3J0IHtBU1NFUlRfVEVYVCwgRVhUUkFDVF9JTkZPfSBmcm9tIFwiLi4vLi4vLi4vY29uc3RhbnRzL0RPTUV2ZW50c1RvUmVjb3JkXCI7XG5pbXBvcnQgRXZlbnRzQ29udHJvbGxlciBmcm9tIFwiLi4vRXZlbnRzQ29udHJvbGxlclwiO1xuLy8gaW1wb3J0IENvZGVNaXJyb3IgZnJvbSBcImNvZGVtaXJyb3JcIjtcbmltcG9ydCB7REVGQVVMVF9WQUxJREFUSU9OX1NDUklQVH0gZnJvbSBcIi4uLy4uLy4uL2NvbnN0YW50c1wiO1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRm9ybVdpemFyZHtcbiAgICByZWNvcmRpbmdPdmVybGF5OiBSZWNvcmRpbmdPdmVybGF5O1xuICAgIGFjdGlvblR5cGU6IHN0cmluZztcbiAgICBldmVudHNDb250cm9sbGVyOiBFdmVudHNDb250cm9sbGVyO1xuXG4gICAgX21vZGFsSGVhZGluZzogYW55O1xuICAgIF9tb2RhbENvbnRlbnRDb250YWluZXI6IGFueTtcbiAgICBfZXh0cmFjdF9ldmVudF9mb3JtOiBhbnk7XG4gICAgX3ZhbGlkYXRpb25TY3JpcHRUZXh0QXJlYTogYW55O1xuICAgIF92YWxpZGF0aW9uU2NyaXB0OiBhbnk7XG4gICAgX2V4dHJhY3RlZEluZm9QcmV2aWV3OiBhbnk7XG4gICAgX2V4dHJhY3RWYXJpYWJsZU5hbWU6IGFueTtcbiAgICBfc3VibWl0RXh0cmFjdEZvcm06IGFueTtcbiAgICBfYXNzZXJ0RXZlbnRGb3JtOiBhbnk7XG4gICAgX2Fzc2VydENvbXBhcmlzaW9uVGV4dDogYW55O1xuICAgIF9hc3NlcnRWYWxpZGF0aW9uOiBhbnk7XG4gICAgX3N1Ym1pdEFzc2VydEZvcm06IGFueTtcblxuXG4gICAgcHJpdmF0ZSBzdGF0ZTogYW55ID0ge1xuICAgICAgICBpc0ludmFsaWRTY3JpcHQ6IGZhbHNlXG4gICAgfTtcblxuICAgIGNvbnN0cnVjdG9yKHJlY29yZGluZ092ZXJsYXk6IFJlY29yZGluZ092ZXJsYXksIGV2ZW50c0NvbnRyb2xsZXI6IEV2ZW50c0NvbnRyb2xsZXIpIHtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmdPdmVybGF5ID0gcmVjb3JkaW5nT3ZlcmxheTtcbiAgICAgICAgdGhpcy5ldmVudHNDb250cm9sbGVyID0gZXZlbnRzQ29udHJvbGxlcjtcbiAgICAgICAgdGhpcy5ldmFsdWF0ZVZhbGlkYXRpb25TY3JpcHQgPSB0aGlzLmV2YWx1YXRlVmFsaWRhdGlvblNjcmlwdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmhhbmRsZVNhdmVFeHRyYWN0Rm9ybSA9IHRoaXMuaGFuZGxlU2F2ZUV4dHJhY3RGb3JtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZXZhbHV0ZUFzc2VydFRleHQgPSB0aGlzLmV2YWx1dGVBc3NlcnRUZXh0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGFuZGxlU2F2ZUFzc2VydEZvcm0gPSB0aGlzLmhhbmRsZVNhdmVBc3NlcnRGb3JtLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgaW5pdE5vZGVzKCl7XG4gICAgICAgIHRoaXMuX21vZGFsSGVhZGluZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIub3ZlcmxheV9oZWFkaW5nX2NvbnRhaW5lciAub3ZlcmxheV9oZWFkaW5nXCIpO1xuICAgICAgICB0aGlzLl9tb2RhbENvbnRlbnRDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLm92ZXJsYXlfbW9kYWxfY29udGVudFwiKTtcbiAgICAgICAgdGhpcy5fZXh0cmFjdF9ldmVudF9mb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNleHRyYWN0X2V2ZW50X2Zvcm1cIik7XG4gICAgICAgIHRoaXMuX2Fzc2VydEV2ZW50Rm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjYXNzZXJ0X2V2ZW50X2Zvcm1cIik7XG4gICAgICAgIHRoaXMuX3ZhbGlkYXRpb25TY3JpcHRUZXh0QXJlYSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjdmFsaWRhdGlvbl9zY3JpcHRcIik7XG4gICAgICAgIHRoaXMuX2Fzc2VydENvbXBhcmlzaW9uVGV4dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjYXNzZXJ0X2NvbXBhcmlzaW9uX3RleHRcIik7XG4gICAgICAgIHRoaXMuX2Fzc2VydFZhbGlkYXRpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Fzc2VydF92YWxpZGF0aW9uXCIpO1xuICAgICAgICB0aGlzLl92YWxpZGF0aW9uU2NyaXB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNleHRyYWN0X2V2ZW50X2Zvcm0gI3ZhbGlkYXRpb25fc2NyaXB0XCIpO1xuICAgICAgICB0aGlzLl9leHRyYWN0ZWRJbmZvUHJldmlldyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZXh0cmFjdF9ldmVudF9mb3JtICNleHRyYWN0ZWRfaW5mb19wcmV2aWV3XCIpO1xuICAgICAgICB0aGlzLl9leHRyYWN0VmFyaWFibGVOYW1lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNleHRyYWN0X3ZhcmlhYmxlX25hbWVcIik7XG4gICAgICAgIHRoaXMuX3N1Ym1pdEV4dHJhY3RGb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNzdWJtaXRfZXh0cmFjdF9mb3JtXCIpO1xuICAgICAgICB0aGlzLl9zdWJtaXRBc3NlcnRGb3JtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNzdWJtaXRfYXNzZXJ0X2Zvcm1cIik7XG4gICAgfVxuXG4gICAgZXZhbHVhdGVWYWxpZGF0aW9uU2NyaXB0KCl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB7dGFyZ2V0RWxlbWVudH0gPSB0aGlzLnJlY29yZGluZ092ZXJsYXkuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRIVE1MID0gdGFyZ2V0RWxlbWVudC5pbm5lckhUTUwudG9TdHJpbmcoKS5yZXBsYWNlKC9cXGAvZywgXCJcXFxcYFwiKS50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBlc2NhcGVkVGV4dCA9IHRhcmdldEVsZW1lbnQuaW5uZXJUZXh0LnJlcGxhY2UoL1xcYC9nLCBcIlxcXFxgXCIpLnRyaW0oKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IGAoYCArIHRoaXMuX3ZhbGlkYXRpb25TY3JpcHQudmFsdWUgKyBgKShgICsgJ2AnICsgZXNjYXBlZEhUTUwgKyAnYCcgKyBgLCBgICsgJ2AnICsgYCR7ZXNjYXBlZFRleHR9YCArICdgJyArIGApYDtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IGV2YWwoc2NyaXB0KTtcbiAgICAgICAgICAgIHRoaXMuX2V4dHJhY3RlZEluZm9QcmV2aWV3LnZhbHVlID0gb3V0cHV0O1xuICAgICAgICAgICAgdGhpcy5fZXh0cmFjdGVkSW5mb1ByZXZpZXcuc3R5bGUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5fdmFsaWRhdGlvblNjcmlwdFRleHRBcmVhLnN0eWxlID0gXCJcIjtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaW52YWxpZCA9IGZhbHNlO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgICAgIHRoaXMuX2V4dHJhY3RlZEluZm9QcmV2aWV3LnN0eWxlID0gXCJib3JkZXI6IDFweCBzb2xpZCByZWQ7XCJcbiAgICAgICAgICAgIHRoaXMuX3ZhbGlkYXRpb25TY3JpcHRUZXh0QXJlYS5zdHlsZSA9IFwiYm9yZGVyOiAxcHggc29saWQgcmVkO1wiO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5pbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVNhdmVFeHRyYWN0Rm9ybSgpe1xuICAgICAgICBjb25zdCB2YXJpYWJsZU5hbWUgPSB0aGlzLl9leHRyYWN0VmFyaWFibGVOYW1lLnZhbHVlO1xuICAgICAgICBjb25zdCBzY3JpcHRDb250ZW50ID0gdGhpcy5fdmFsaWRhdGlvblNjcmlwdC52YWx1ZTtcbiAgICAgICAgY29uc3Qge2lzSW52YWxpZFNjcmlwdH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7dGFyZ2V0RWxlbWVudH0gPSB0aGlzLnJlY29yZGluZ092ZXJsYXkuZ2V0U3RhdGUoKTtcblxuICAgICAgICBpZighaXNJbnZhbGlkU2NyaXB0ICYmIHZhcmlhYmxlTmFtZSAmJiBzY3JpcHRDb250ZW50KXtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgICAgICAgICAgICAgICBbdmFyaWFibGVOYW1lXTogc2NyaXB0Q29udGVudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgdGhpcy5ldmVudHNDb250cm9sbGVyLnNhdmVDYXB0dXJlZEV2ZW50SW5CYWNrZ3JvdW5kKEVYVFJBQ1RfSU5GTywgdGFyZ2V0RWxlbWVudCwgcGF5bG9hZCk7XG4gICAgICAgICAgIHRoaXMucmVjb3JkaW5nT3ZlcmxheS50b2dnbGVFdmVudHNCb3goKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGlzSW52YWxpZFNjcmlwdCwgdmFyaWFibGVOYW1lLCBzY3JpcHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZVNhdmVBc3NlcnRGb3JtKCl7XG4gICAgICAgIGNvbnN0IGNvbXBhcmlzaW9uVGV4dCA9IHRoaXMuX2Fzc2VydENvbXBhcmlzaW9uVGV4dC52YWx1ZTtcbiAgICAgICAgY29uc3Qge3RhcmdldEVsZW1lbnR9ID0gdGhpcy5yZWNvcmRpbmdPdmVybGF5LmdldFN0YXRlKCk7XG4gICAgICAgIHRoaXMuZXZlbnRzQ29udHJvbGxlci5zYXZlQ2FwdHVyZWRFdmVudEluQmFja2dyb3VuZChBU1NFUlRfVEVYVCwgdGFyZ2V0RWxlbWVudCwgY29tcGFyaXNpb25UZXh0KTtcbiAgICAgICAgdGhpcy5yZWNvcmRpbmdPdmVybGF5LnRvZ2dsZUV2ZW50c0JveCgpO1xuXG4gICAgfVxuXG4gICAgaW5pdEV2ZW50TGlzdGVuZXIoKXtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGlvblNjcmlwdC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5ldmFsdWF0ZVZhbGlkYXRpb25TY3JpcHQpO1xuICAgICAgICB0aGlzLl9zdWJtaXRFeHRyYWN0Rm9ybS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5oYW5kbGVTYXZlRXh0cmFjdEZvcm0pO1xuXG4gICAgICAgIHRoaXMuX2Fzc2VydENvbXBhcmlzaW9uVGV4dC5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgdGhpcy5ldmFsdXRlQXNzZXJ0VGV4dCk7XG4gICAgICAgIHRoaXMuX3N1Ym1pdEFzc2VydEZvcm0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuaGFuZGxlU2F2ZUFzc2VydEZvcm0pO1xuICAgIH1cblxuICAgIGV2YWx1dGVBc3NlcnRUZXh0KCl7XG4gICAgICAgIGNvbnN0IHt0YXJnZXRFbGVtZW50fSA9IHRoaXMucmVjb3JkaW5nT3ZlcmxheS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZih0YXJnZXRFbGVtZW50ICYmIHRhcmdldEVsZW1lbnQuaW5uZXJUZXh0ID09PSB0aGlzLl9hc3NlcnRDb21wYXJpc2lvblRleHQudmFsdWUpe1xuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0VmFsaWRhdGlvbi52YWx1ZSA9IFwiVFJVRVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYXNzZXJ0VmFsaWRhdGlvbi52YWx1ZSA9IFwiRkFMU0VcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0RXh0cmFjdEZpZWxkcygpe1xuICAgICAgICB0aGlzLl9leHRyYWN0VmFyaWFibGVOYW1lLnZhbHVlID0gXCJcIjtcbiAgICAgICAgdGhpcy5fdmFsaWRhdGlvblNjcmlwdC52YWx1ZSA9IERFRkFVTFRfVkFMSURBVElPTl9TQ1JJUFQ7XG4gICAgICAgIHRoaXMuX2V4dHJhY3RlZEluZm9QcmV2aWV3LnZhbHVlID0gXCJcIjtcbiAgICB9XG5cbiAgICBpbml0QXNzZXJ0RmllbGRzKCl7XG4gICAgICAgIGNvbnN0IHt0YXJnZXRFbGVtZW50fSA9IHRoaXMucmVjb3JkaW5nT3ZlcmxheS5nZXRTdGF0ZSgpO1xuICAgICAgICB0aGlzLl9hc3NlcnRDb21wYXJpc2lvblRleHQudmFsdWUgPSB0YXJnZXRFbGVtZW50LmlubmVyVGV4dDtcbiAgICB9XG5cbiAgICByZW5kZXJGb3JtKCl7XG4gICAgICAgIHN3aXRjaCh0aGlzLmFjdGlvblR5cGUpe1xuICAgICAgICAgICAgY2FzZSBFWFRSQUNUX0lORk86XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNldEV4dHJhY3RGaWVsZHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RhbEhlYWRpbmcuaW5uZXJIVE1MID0gXCJFeHRyYWN0IEluZm8gRm9ybVwiO1xuICAgICAgICAgICAgICAgIHRoaXMuX2V4dHJhY3RfZXZlbnRfZm9ybS5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWdvbmVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmFsdWF0ZVZhbGlkYXRpb25TY3JpcHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQVNTRVJUX1RFWFQ6XG4gICAgICAgICAgICAgICAgdGhpcy5pbml0QXNzZXJ0RmllbGRzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kYWxIZWFkaW5nLmlubmVySFRNTCA9IFwiQXNzZXJ0IFRleHRcIjtcbiAgICAgICAgICAgICAgICB0aGlzLl9hc3NlcnRFdmVudEZvcm0ucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS1nb25lXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZXZhbHV0ZUFzc2VydFRleHQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJvb3QoYWN0aW9uVHlwZTogc3RyaW5nKXtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyhcIkZvcm0gd2l6YXJkIGJvb3RlZCB1cFwiKTtcbiAgICAgICAgdGhpcy5pbml0Tm9kZXMoKTtcbiAgICAgICAgdGhpcy5pbml0RXZlbnRMaXN0ZW5lcigpO1xuXG4gICAgICAgIHRoaXMuYWN0aW9uVHlwZSA9IGFjdGlvblR5cGU7XG4gICAgICAgIC8vIEhpZGUgYWxsIGZvcm1zIGFuZCBzaG93IHRoZSBldmVudCBmb3JtXG4gICAgICAgIHNldEF0dHJpYnV0ZUZvckFsbENoaWxkTm9kZXModGhpcy5fbW9kYWxDb250ZW50Q29udGFpbmVyLCBcImRhdGEtZ29uZVwiLCBcInRydWVcIik7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJGb3JtKCk7XG4gICAgfVxuXG59XG4iXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUFBO0FBdUJBO0FBSkE7QUFDQTtBQURBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFBQTtBQUNBO0FBWkE7QUFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///22\n')},,,,,,,function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"createPopper\", function() { return /* binding */ popper_createPopper; });\n__webpack_require__.d(__webpack_exports__, \"popperGenerator\", function() { return /* reexport */ popperGenerator; });\n__webpack_require__.d(__webpack_exports__, \"defaultModifiers\", function() { return /* binding */ popper_defaultModifiers; });\n__webpack_require__.d(__webpack_exports__, \"detectOverflow\", function() { return /* reexport */ detectOverflow; });\n\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\nfunction getBoundingClientRect(element) {\n  var rect = element.getBoundingClientRect();\n  return {\n    width: rect.width,\n    height: rect.height,\n    top: rect.top,\n    right: rect.right,\n    bottom: rect.bottom,\n    left: rect.left,\n    x: rect.left,\n    y: rect.top\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\n/*:: import type { Window } from '../types'; */\n\n/*:: declare function getWindow(node: Node | Window): Window; */\nfunction getWindow(node) {\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView : window;\n  }\n\n  return node;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\n\nfunction getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\n\n/*:: declare function isElement(node: mixed): boolean %checks(node instanceof\n  Element); */\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n/*:: declare function isHTMLElement(node: mixed): boolean %checks(node instanceof\n  HTMLElement); */\n\n\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\n\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\n\n\n\n\nfunction getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe: assume body is always available\n  return (isElement(element) ? element.ownerDocument : element.document).documentElement;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\n\n\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\n\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\n\n\n\n\n\n\n // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (!isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\n// Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\nfunction getLayoutRect(element) {\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: element.offsetWidth,\n    height: element.offsetHeight\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\n\n\nfunction getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// $FlowFixMe: this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || // DOM Element detected\n    // $FlowFixMe: need a better way to handle this...\n    element.host || // ShadowRoot detected\n    // $FlowFixMe: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\n\n\n\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\n\n\n\n\n\nfunction listScrollParents(element, list) {\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = getScrollParent(element);\n  var isBody = getNodeName(scrollParent) === 'body';\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\n\n\n\n\n\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n}\n\nfunction getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element); // Find the nearest non-table offsetParent\n\n  while (offsetParent && isTableElement(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static') {\n    return window;\n  }\n\n  return offsetParent || window;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/enums.js\nvar enums_top = 'top';\nvar bottom = 'bottom';\nvar right = 'right';\nvar left = 'left';\nvar auto = 'auto';\nvar basePlacements = [enums_top, bottom, right, left];\nvar start = 'start';\nvar end = 'end';\nvar enums_clippingParents = 'clippingParents';\nvar viewport = 'viewport';\nvar enums_popper = 'popper';\nvar enums_reference = 'reference';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar enums_placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = 'beforeRead';\nvar read = 'read';\nvar afterRead = 'afterRead'; // pure-logic modifiers\n\nvar beforeMain = 'beforeMain';\nvar main = 'main';\nvar afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = 'beforeWrite';\nvar write = 'write';\nvar afterWrite = 'afterWrite';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/orderModifiers.js\n // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/debounce.js\nfunction debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergeByName.js\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, {}, current, {\n      options: Object.assign({}, existing.options, {}, current.options),\n      data: Object.assign({}, existing.data, {}, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/index.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar INVALID_ELEMENT_ERROR = 'Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.';\nvar INFINITE_LOOP_ERROR = 'Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.';\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, {}, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(options) {\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, {}, state.options, {}, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        }); // Validate the provided modifiers so that the consumer will get warned\n        // if one of the modifiers is invalid for any reason\n\n        if (false) { var _getComputedStyle, marginTop, marginRight, marginBottom, marginLeft, flipModifier, modifiers; }\n\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          if (false) {}\n\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        var __debug_loops__ = 0;\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (false) {}\n\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      if (false) {}\n\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref3) {\n        var name = _ref3.name,\n            _ref3$options = _ref3.options,\n            options = _ref3$options === void 0 ? {} : _ref3$options,\n            effect = _ref3.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nvar lib_createPopper = /*#__PURE__*/popperGenerator();\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\n // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var eventListeners = ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\n\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getVariation.js\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeOffsets.js\n\n\n\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case enums_top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = Math.floor(offsets[mainAxis]) - Math.floor(reference[len] / 2 - element[len] / 2);\n        break;\n\n      case end:\n        offsets[mainAxis] = Math.floor(offsets[mainAxis]) + Math.ceil(reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\n\n\nfunction popperOffsets_popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_popperOffsets = ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets_popperOffsets,\n  data: {}\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsets(_ref) {\n  var x = _ref.x,\n      y = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: Math.round(x * dpr) / dpr || 0,\n    y: Math.round(y * dpr) / dpr || 0\n  };\n}\n\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive;\n\n  var _roundOffsets = roundOffsets(offsets),\n      x = _roundOffsets.x,\n      y = _roundOffsets.y;\n\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = enums_top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n    } // $FlowFixMe: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n    /*:: offsetParent = (offsetParent: Element); */\n\n\n    if (placement === enums_top) {\n      sideY = bottom;\n      y -= offsetParent.clientHeight - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left) {\n      sideX = right;\n      x -= offsetParent.clientWidth - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) < 2 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref3) {\n  var state = _ref3.state,\n      options = _ref3.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive;\n\n  if (false) { var transitionProperty; }\n\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, {}, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, {}, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_computeStyles = ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\n\n // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction applyStyles_effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      } // Flow doesn't support to extend this property, but it's the most\n      // effective way to apply styles to an HTMLElement\n      // $FlowFixMe\n\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_applyStyles = ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: applyStyles_effect,\n  requires: ['computeStyles']\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/offset.js\n\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, enums_top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset_offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = enums_placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_offset = ({\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset_offset\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\nvar hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\nvar getOppositeVariationPlacement_hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return getOppositeVariationPlacement_hash[matched];\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\n\nfunction getViewportRect(element) {\n  var win = getWindow(element);\n  var visualViewport = win.visualViewport;\n  var width = win.innerWidth;\n  var height = win.innerHeight; // We don't know which browsers have buggy or odd implementations of this, so\n  // for now we're only applying it to iOS to fix the keyboard issue.\n  // Investigation required\n\n  if (visualViewport && /iPhone|iPod|iPad/.test(navigator.platform)) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: 0,\n    y: 0\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\n\n\n\n\nfunction getDocumentRect(element) {\n  var win = getWindow(element);\n  var winScroll = getWindowScroll(element);\n  var documentRect = getCompositeRect(getDocumentElement(element), win);\n  documentRect.height = Math.max(documentRect.height, win.innerHeight);\n  documentRect.width = Math.max(documentRect.width, win.innerWidth);\n  documentRect.x = -winScroll.scrollLeft;\n  documentRect.y = -winScroll.scrollTop;\n  return documentRect;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getBorders.js\n\n\n\nfunction toNumber(cssValue) {\n  return parseFloat(cssValue) || 0;\n}\n\nfunction getBorders(element) {\n  var computedStyle = isHTMLElement(element) ? getComputedStyle(element) : {};\n  return {\n    top: toNumber(computedStyle.borderTopWidth),\n    right: toNumber(computedStyle.borderRightWidth),\n    bottom: toNumber(computedStyle.borderBottomWidth),\n    left: toNumber(computedStyle.borderLeftWidth)\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getDecorations.js\n\n\n\n // Borders + scrollbars\n\nfunction getDecorations(element) {\n  var win = getWindow(element);\n  var borders = getBorders(element);\n  var isHTML = getNodeName(element) === 'html';\n  var winScrollBarX = getWindowScrollBarX(element);\n  var x = element.clientWidth + borders.right;\n  var y = element.clientHeight + borders.bottom; // HACK:\n  // document.documentElement.clientHeight on iOS reports the height of the\n  // viewport including the bottom bar, even if the bottom bar isn't visible.\n  // If the difference between window innerHeight and html clientHeight is more\n  // than 50, we assume it's a mobile bottom bar and ignore scrollbars.\n  // * A 50px thick scrollbar is likely non-existent (macOS is 15px and Windows\n  //   is about 17px)\n  // * The mobile bar is 114px tall\n\n  if (isHTML && win.innerHeight - element.clientHeight > 50) {\n    y = win.innerHeight - borders.bottom;\n  }\n\n  return {\n    top: isHTML ? 0 : element.clientTop,\n    right: // RTL scrollbar (scrolling containers only)\n    element.clientLeft > borders.left ? borders.right : // LTR scrollbar\n    isHTML ? win.innerWidth - x - winScrollBarX : element.offsetWidth - x,\n    bottom: isHTML ? win.innerHeight - y : element.offsetHeight - y,\n    left: isHTML ? winScrollBarX : element.clientLeft\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/contains.js\nfunction contains(parent, child) {\n  // $FlowFixMe: hasOwnProperty doesn't seem to work in tests\n  var isShadow = Boolean(child.getRootNode && child.getRootNode().host); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (isShadow) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getClientRectFromMixedType(element, clippingParent) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element)) : isHTMLElement(clippingParent) ? getBoundingClientRect(clippingParent) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(element);\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement);\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent);\n    var decorations = getDecorations(isHTMLElement(clippingParent) ? clippingParent : getDocumentElement(element));\n    accRect.top = Math.max(rect.top + decorations.top, accRect.top);\n    accRect.right = Math.min(rect.right - decorations.right, accRect.right);\n    accRect.bottom = Math.min(rect.bottom - decorations.bottom, accRect.bottom);\n    accRect.left = Math.max(rect.left + decorations.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), {}, paddingObject);\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/detectOverflow.js\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? enums_clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? enums_popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === enums_popper ? enums_reference : enums_popper;\n  var referenceElement = state.elements.reference;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary);\n  var referenceClientRect = getBoundingClientRect(referenceElement);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, {}, popperOffsets));\n  var elementClientRect = elementContext === enums_popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === enums_popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [enums_top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\n\n\n\n\n\n/*:: type OverflowsMap = { [ComputedPlacement]: number }; */\n\n/*;; type OverflowsMap = { [key in ComputedPlacement]: number }; */\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements = (variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements).filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  }); // $FlowFixMe: Flow seems to have problems with two array unions...\n\n  var overflows = placements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/flip.js\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [enums_top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_flip = ({\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/getAltAxis.js\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/utils/within.js\nfunction within(min, value, max) {\n  return Math.max(min, Math.min(value, max));\n}\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\n\n\n\n\n\n\n\n\n\n\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var mainSide = mainAxis === 'y' ? enums_top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = popperOffsets[mainAxis] + overflow[mainSide];\n    var max = popperOffsets[mainAxis] - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - tetherOffsetValue : minLen - arrowLen - arrowPaddingMin - tetherOffsetValue;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + tetherOffsetValue : maxLen + arrowLen + arrowPaddingMax + tetherOffsetValue;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = state.modifiersData.offset ? state.modifiersData.offset[state.placement][mainAxis] : 0;\n    var tetherMin = popperOffsets[mainAxis] + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = popperOffsets[mainAxis] + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? Math.min(min, tetherMin) : min, offset, tether ? Math.max(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _mainSide = mainAxis === 'x' ? enums_top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var _preventedOffset = within(_min, _offset, _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_preventOverflow = ({\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/arrow.js\n\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = state.modifiersData[name + \"#persistent\"].padding;\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? enums_top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction arrow_effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element,\n      _options$padding = options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (false) {}\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    if (false) {}\n\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n  state.modifiersData[name + \"#persistent\"] = {\n    padding: mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements))\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_arrow = ({\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: arrow_effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/modifiers/hide.js\n\n\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [enums_top, right, bottom, left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ var modifiers_hide = ({\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n});\n// CONCATENATED MODULE: ./node_modules/@popperjs/core/lib/popper.js\n\n\n\n\n\n\n\n\n\n\n\nvar popper_defaultModifiers = [eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide];\nvar popper_createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: popper_defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanM/MGY4OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanM/MWZjMCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGwuanM/YTMyMSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzPzI3NjciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanM/NWZlNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzPzE5OWEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanM/NTc4OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanM/ZWY1MiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzPzYxMjUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qcz9iNTE5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzP2FlNmMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q29tcG9zaXRlUmVjdC5qcz9kMTE2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanM/ZTJlOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzPzI4YmYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0U2Nyb2xsUGFyZW50LmpzPzlkMGUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvbGlzdFNjcm9sbFBhcmVudHMuanM/ZWExYSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9pc1RhYmxlRWxlbWVudC5qcz9iNDUxIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcz9iNjJiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanM/NzdmOSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzP2I5ZTYiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZWJvdW5jZS5qcz9iMWUyIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanM/MmEzNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2luZGV4LmpzPzEyMzUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanM/YWQ2ZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanM/YjUwZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldFZhcmlhdGlvbi5qcz8zZDhkIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzP2FkOWQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qcz81ZDdlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanM/MTM0YSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9jb21wdXRlU3R5bGVzLmpzPzdjZGEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanM/MGFiNCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9vZmZzZXQuanM/OTgzNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzPzUyMzIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudC5qcz81MDBiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFZpZXdwb3J0UmVjdC5qcz83YzczIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcz8zZTc5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvcmRlcnMuanM/ZDI0MyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXREZWNvcmF0aW9ucy5qcz8zNDJhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzPzdmMzciLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzPzdiY2YiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzPzlkZTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanM/MzVmNiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qcz9kMzliIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzPzk4NTIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcz9iNjE3Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanM/NDNjZSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzP2VjYjIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRBbHRBeGlzLmpzP2YyZTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy93aXRoaW4uanM/ZTQzZiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9wcmV2ZW50T3ZlcmZsb3cuanM/OTQzNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9hcnJvdy5qcz8wOTI5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2hpZGUuanM/MWQ2YyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3BvcHBlci5qcz8zOWMzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0LFxuICAgIHRvcDogcmVjdC50b3AsXG4gICAgcmlnaHQ6IHJlY3QucmlnaHQsXG4gICAgYm90dG9tOiByZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgeDogcmVjdC5sZWZ0LFxuICAgIHk6IHJlY3QudG9wXG4gIH07XG59IiwiLyo6OiBpbXBvcnQgdHlwZSB7IFdpbmRvdyB9IGZyb20gJy4uL3R5cGVzJzsgKi9cblxuLyo6OiBkZWNsYXJlIGZ1bmN0aW9uIGdldFdpbmRvdyhub2RlOiBOb2RlIHwgV2luZG93KTogV2luZG93OyAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93KG5vZGUpIHtcbiAgaWYgKG5vZGUudG9TdHJpbmcoKSAhPT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn0iLCJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsKG5vZGUpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhub2RlKTtcbiAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gIHZhciBzY3JvbGxUb3AgPSB3aW4ucGFnZVlPZmZzZXQ7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICBzY3JvbGxUb3A6IHNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG4vKjo6IGRlY2xhcmUgZnVuY3Rpb24gaXNFbGVtZW50KG5vZGU6IG1peGVkKTogYm9vbGVhbiAlY2hlY2tzKG5vZGUgaW5zdGFuY2VvZlxuICBFbGVtZW50KTsgKi9cblxuZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50O1xufVxuLyo6OiBkZWNsYXJlIGZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZTogbWl4ZWQpOiBib29sZWFuICVjaGVja3Mobm9kZSBpbnN0YW5jZW9mXG4gIEhUTUxFbGVtZW50KTsgKi9cblxuXG5mdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuSFRNTEVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG59XG5cbmV4cG9ydCB7IGlzRWxlbWVudCwgaXNIVE1MRWxlbWVudCB9OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufSIsImltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRIVE1MRWxlbWVudFNjcm9sbCBmcm9tIFwiLi9nZXRIVE1MRWxlbWVudFNjcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcbiAgICByZXR1cm4gZ2V0V2luZG93U2Nyb2xsKG5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE5vZGVOYW1lKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XG59IiwiaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIHtcbiAgLy8gJEZsb3dGaXhNZTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICByZXR1cm4gKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IGVsZW1lbnQuZG9jdW1lbnQpLmRvY3VtZW50RWxlbWVudDtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50RWxlbWVudCBmcm9tIFwiLi9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGwgZnJvbSBcIi4vZ2V0V2luZG93U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcbiAgLy8gSWYgPGh0bWw+IGhhcyBhIENTUyB3aWR0aCBncmVhdGVyIHRoYW4gdGhlIHZpZXdwb3J0LCB0aGVuIHRoaXMgd2lsbCBiZVxuICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcbiAgLy8gaXQncyBub3QgYW4gaXNzdWUuIEkgZG9uJ3QgdGhpbmsgYW55b25lIGV2ZXIgc3BlY2lmaWVzIHdpZHRoIG9uIDxodG1sPlxuICAvLyBhbnl3YXkuXG4gIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXG4gIC8vIHRoaXMgKGUuZy4gRWRnZSAyMDE5LCBJRTExLCBTYWZhcmkpXG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICByZXR1cm4gZ2V0V2luZG93KGVsZW1lbnQpLmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG59IiwiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSIsImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZVNjcm9sbCBmcm9tIFwiLi9nZXROb2RlU2Nyb2xsLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGlzU2Nyb2xsUGFyZW50IGZyb20gXCIuL2lzU2Nyb2xsUGFyZW50LmpzXCI7IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcG9zaXRlUmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50LCBpc0ZpeGVkKSB7XG4gIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkID0gZmFsc2U7XG4gIH1cblxuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50KTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoIWlzRml4ZWQpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gJ2JvZHknIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTA3OFxuICAgIGlzU2Nyb2xsUGFyZW50KGRvY3VtZW50RWxlbWVudCkpIHtcbiAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICB9XG5cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XG4gICAgICBvZmZzZXRzLnkgKz0gb2Zmc2V0UGFyZW50LmNsaWVudFRvcDtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXG4gICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgIHdpZHRoOiByZWN0LndpZHRoLFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHRcbiAgfTtcbn0iLCIvLyBSZXR1cm5zIHRoZSBsYXlvdXQgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuIExheW91dFxuLy8gbWVhbnMgaXQgZG9lc24ndCB0YWtlIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zLlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoLFxuICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gJEZsb3dGaXhNZTogdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICBlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCAvLyBzdGVwIGludG8gdGhlIHNoYWRvdyBET00gb2YgdGhlIHBhcmVudCBvZiBhIHNsb3R0ZWQgbm9kZVxuICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIC8vICRGbG93Rml4TWU6IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXG4gICAgZWxlbWVudC5ob3N0IHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lOiBIVE1MRWxlbWVudCBpcyBhIE5vZGVcbiAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICApO1xufSIsImltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59IiwiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgbGlzdCA9IFtdO1xuICB9XG5cbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgdmFyIGlzQm9keSA9IGdldE5vZGVOYW1lKHNjcm9sbFBhcmVudCkgPT09ICdib2R5JztcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhzY3JvbGxQYXJlbnQpO1xuICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcbiAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgcmV0dXJuIGlzQm9keSA/IHVwZGF0ZWRMaXN0IDogLy8gJEZsb3dGaXhNZTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSIsImltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBpc1RhYmxlRWxlbWVudCBmcm9tIFwiLi9pc1RhYmxlRWxlbWVudC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvODM3XG4gIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7IC8vIEZpbmQgdGhlIG5lYXJlc3Qgbm9uLXRhYmxlIG9mZnNldFBhcmVudFxuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIGlmIChvZmZzZXRQYXJlbnQgJiYgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gd2luZG93O1xuICB9XG5cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCB3aW5kb3c7XG59IiwiZXhwb3J0IHZhciB0b3AgPSAndG9wJztcbmV4cG9ydCB2YXIgYm90dG9tID0gJ2JvdHRvbSc7XG5leHBvcnQgdmFyIHJpZ2h0ID0gJ3JpZ2h0JztcbmV4cG9ydCB2YXIgbGVmdCA9ICdsZWZ0JztcbmV4cG9ydCB2YXIgYXV0byA9ICdhdXRvJztcbmV4cG9ydCB2YXIgYmFzZVBsYWNlbWVudHMgPSBbdG9wLCBib3R0b20sIHJpZ2h0LCBsZWZ0XTtcbmV4cG9ydCB2YXIgc3RhcnQgPSAnc3RhcnQnO1xuZXhwb3J0IHZhciBlbmQgPSAnZW5kJztcbmV4cG9ydCB2YXIgY2xpcHBpbmdQYXJlbnRzID0gJ2NsaXBwaW5nUGFyZW50cyc7XG5leHBvcnQgdmFyIHZpZXdwb3J0ID0gJ3ZpZXdwb3J0JztcbmV4cG9ydCB2YXIgcG9wcGVyID0gJ3BvcHBlcic7XG5leHBvcnQgdmFyIHJlZmVyZW5jZSA9ICdyZWZlcmVuY2UnO1xuZXhwb3J0IHZhciB2YXJpYXRpb25QbGFjZW1lbnRzID0gLyojX19QVVJFX18qL2Jhc2VQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XG59LCBbXSk7XG5leHBvcnQgdmFyIHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxuZXhwb3J0IHZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xuZXhwb3J0IHZhciByZWFkID0gJ3JlYWQnO1xuZXhwb3J0IHZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxuZXhwb3J0IHZhciBiZWZvcmVNYWluID0gJ2JlZm9yZU1haW4nO1xuZXhwb3J0IHZhciBtYWluID0gJ21haW4nO1xuZXhwb3J0IHZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG5leHBvcnQgdmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcbmV4cG9ydCB2YXIgd3JpdGUgPSAnd3JpdGUnO1xuZXhwb3J0IHZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xuZXhwb3J0IHZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTsiLCJpbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5ODc1MjU1XG5cbmZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcbiAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XG4gICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XG4gICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xuICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcbiAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCB7fSwgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywge30sIGN1cnJlbnQub3B0aW9ucyksXG4gICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5kYXRhLCB7fSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufSIsImltcG9ydCBnZXRDb21wb3NpdGVSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGxpc3RTY3JvbGxQYXJlbnRzIGZyb20gXCIuL2RvbS11dGlscy9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IG9yZGVyTW9kaWZpZXJzIGZyb20gXCIuL3V0aWxzL29yZGVyTW9kaWZpZXJzLmpzXCI7XG5pbXBvcnQgZGVib3VuY2UgZnJvbSBcIi4vdXRpbHMvZGVib3VuY2UuanNcIjtcbmltcG9ydCB2YWxpZGF0ZU1vZGlmaWVycyBmcm9tIFwiLi91dGlscy92YWxpZGF0ZU1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IHVuaXF1ZUJ5IGZyb20gXCIuL3V0aWxzL3VuaXF1ZUJ5LmpzXCI7XG5pbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4vZW51bXMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2VudW1zLmpzXCI7XG52YXIgSU5WQUxJRF9FTEVNRU5UX0VSUk9SID0gJ1BvcHBlcjogSW52YWxpZCByZWZlcmVuY2Ugb3IgcG9wcGVyIGFyZ3VtZW50IHByb3ZpZGVkLiBUaGV5IG11c3QgYmUgZWl0aGVyIGEgRE9NIGVsZW1lbnQgb3IgdmlydHVhbCBlbGVtZW50Lic7XG52YXIgSU5GSU5JVEVfTE9PUF9FUlJPUiA9ICdQb3BwZXI6IEFuIGluZmluaXRlIGxvb3AgaW4gdGhlIG1vZGlmaWVycyBjeWNsZSBoYXMgYmVlbiBkZXRlY3RlZCEgVGhlIGN5Y2xlIGhhcyBiZWVuIGludGVycnVwdGVkIHRvIHByZXZlbnQgYSBicm93c2VyIGNyYXNoLic7XG52YXIgREVGQVVMVF9PUFRJT05TID0ge1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICBtb2RpZmllcnM6IFtdLFxuICBzdHJhdGVneTogJ2Fic29sdXRlJ1xufTtcblxuZnVuY3Rpb24gYXJlVmFsaWRFbGVtZW50cygpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHJldHVybiAhYXJncy5zb21lKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywge30sIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgIG1vZGlmaWVyc0RhdGE6IHt9LFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlcjogcG9wcGVyXG4gICAgICB9LFxuICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfTtcbiAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHZhciBpbnN0YW5jZSA9IHtcbiAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywge30sIHN0YXRlLm9wdGlvbnMsIHt9LCBvcHRpb25zKTtcbiAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICBwb3BwZXI6IGxpc3RTY3JvbGxQYXJlbnRzKHBvcHBlcilcbiAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXG4gICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICB2YXIgb3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyTW9kaWZpZXJzKG1lcmdlQnlOYW1lKFtdLmNvbmNhdChkZWZhdWx0TW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycykpKTsgLy8gU3RyaXAgb3V0IGRpc2FibGVkIG1vZGlmaWVyc1xuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobSkge1xuICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgIH0pOyAvLyBWYWxpZGF0ZSB0aGUgcHJvdmlkZWQgbW9kaWZpZXJzIHNvIHRoYXQgdGhlIGNvbnN1bWVyIHdpbGwgZ2V0IHdhcm5lZFxuICAgICAgICAvLyBpZiBvbmUgb2YgdGhlIG1vZGlmaWVycyBpcyBpbnZhbGlkIGZvciBhbnkgcmVhc29uXG5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgIHZhciBtb2RpZmllcnMgPSB1bmlxdWVCeShbXS5jb25jYXQob3JkZXJlZE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgICAgICAgICByZXR1cm4gbmFtZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YWxpZGF0ZU1vZGlmaWVycyhtb2RpZmllcnMpO1xuXG4gICAgICAgICAgaWYgKGdldEJhc2VQbGFjZW1lbnQoc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgICAgICAgICB2YXIgZmxpcE1vZGlmaWVyID0gc3RhdGUub3JkZXJlZE1vZGlmaWVycy5maW5kKGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYyLm5hbWU7XG4gICAgICAgICAgICAgIHJldHVybiBuYW1lID09PSAnZmxpcCc7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKCFmbGlwTW9kaWZpZXIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhdXRvXCIgcGxhY2VtZW50cyByZXF1aXJlIHRoZSBcImZsaXBcIiBtb2RpZmllciBiZScsICdwcmVzZW50IGFuZCBlbmFibGVkIHRvIHdvcmsuJ10uam9pbignICcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHBvcHBlciksXG4gICAgICAgICAgICAgIG1hcmdpblRvcCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblRvcCxcbiAgICAgICAgICAgICAgbWFyZ2luUmlnaHQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5SaWdodCxcbiAgICAgICAgICAgICAgbWFyZ2luQm90dG9tID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luQm90dG9tLFxuICAgICAgICAgICAgICBtYXJnaW5MZWZ0ID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luTGVmdDsgLy8gV2Ugbm8gbG9uZ2VyIHRha2UgaW50byBhY2NvdW50IGBtYXJnaW5zYCBvbiB0aGUgcG9wcGVyLCBhbmQgaXQgY2FuXG4gICAgICAgICAgLy8gY2F1c2UgYnVncyB3aXRoIHBvc2l0aW9uaW5nLCBzbyB3ZSdsbCB3YXJuIHRoZSBjb25zdW1lclxuXG5cbiAgICAgICAgICBpZiAoW21hcmdpblRvcCwgbWFyZ2luUmlnaHQsIG1hcmdpbkJvdHRvbSwgbWFyZ2luTGVmdF0uc29tZShmdW5jdGlvbiAobWFyZ2luKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChtYXJnaW4pO1xuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IENTUyBcIm1hcmdpblwiIHN0eWxlcyBjYW5ub3QgYmUgdXNlZCB0byBhcHBseSBwYWRkaW5nJywgJ2JldHdlZW4gdGhlIHBvcHBlciBhbmQgaXRzIHJlZmVyZW5jZSBlbGVtZW50IG9yIGJvdW5kYXJ5LicsICdUbyByZXBsaWNhdGUgbWFyZ2luLCB1c2UgdGhlIGBvZmZzZXRgIG1vZGlmaWVyLCBhcyB3ZWxsIGFzJywgJ3RoZSBgcGFkZGluZ2Agb3B0aW9uIGluIHRoZSBgcHJldmVudE92ZXJmbG93YCBhbmQgYGZsaXBgJywgJ21vZGlmaWVycy4nXS5qb2luKCcgJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJ1bk1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XG4gICAgICB9LFxuICAgICAgLy8gU3luYyB1cGRhdGUg4oCTIGl0IHdpbGwgYWx3YXlzIGJlIGV4ZWN1dGVkLCBldmVuIGlmIG5vdCBuZWNlc3NhcnkuIFRoaXNcbiAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcbiAgICAgIC8vIGxvZ2ljLlxuICAgICAgLy8gRm9yIGhpZ2ggZnJlcXVlbmN5IHVwZGF0ZXMgKGUuZy4gYHJlc2l6ZWAgYW5kIGBzY3JvbGxgIGV2ZW50cyksIGFsd2F5c1xuICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxuICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICBpZiAoaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX3N0YXRlJGVsZW1lbnRzID0gc3RhdGUuZWxlbWVudHMsXG4gICAgICAgICAgICByZWZlcmVuY2UgPSBfc3RhdGUkZWxlbWVudHMucmVmZXJlbmNlLFxuICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgIC8vIGFueW1vcmVcblxuICAgICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBTdG9yZSB0aGUgcmVmZXJlbmNlIGFuZCBwb3BwZXIgcmVjdHMgdG8gYmUgcmVhZCBieSBtb2RpZmllcnNcblxuXG4gICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogZ2V0Q29tcG9zaXRlUmVjdChyZWZlcmVuY2UsIGdldE9mZnNldFBhcmVudChwb3BwZXIpLCBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnKSxcbiAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxuICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAvLyBtb3N0IGNvbW1vbiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB0aGUgYGZsaXBgIG1vZGlmaWVyIGNoYW5naW5nIHRoZVxuICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxuICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAvLyBzdGFsZS9pbmNvcnJlY3RcblxuICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgLy8gaXMgZmlsbGVkIHdpdGggdGhlIGluaXRpYWwgZGF0YSBzcGVjaWZpZWQgYnkgdGhlIG1vZGlmaWVyLiBUaGlzIG1lYW5zXG4gICAgICAgIC8vIGl0IGRvZXNuJ3QgcGVyc2lzdCBhbmQgaXMgZnJlc2ggb24gZWFjaCB1cGRhdGUuXG4gICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICByZXR1cm4gc3RhdGUubW9kaWZpZXJzRGF0YVttb2RpZmllci5uYW1lXSA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGlmaWVyLmRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF9fZGVidWdfbG9vcHNfXyA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgX19kZWJ1Z19sb29wc19fICs9IDE7XG5cbiAgICAgICAgICAgIGlmIChfX2RlYnVnX2xvb3BzX18gPiAxMDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihJTkZJTklURV9MT09QX0VSUk9SKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSU5WQUxJRF9FTEVNRU5UX0VSUk9SKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICghaXNEZXN0cm95ZWQgJiYgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIGV4ZWN1dGUgYXJiaXRyYXJ5IGNvZGUgYmVmb3JlIHRoZSBmaXJzdFxuICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XG4gICAgLy8gb3RoZXIgbW9kaWZpZXJzIG5lZWQgdG8gdXNlLCBidXQgdGhlIG1vZGlmaWVyIGlzIHJ1biBhZnRlciB0aGUgZGVwZW5kZW50XG4gICAgLy8gb25lLlxuXG4gICAgZnVuY3Rpb24gcnVuTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYzLm5hbWUsXG4gICAgICAgICAgICBfcmVmMyRvcHRpb25zID0gX3JlZjMub3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmMyRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYzJG9wdGlvbnMsXG4gICAgICAgICAgICBlZmZlY3QgPSBfcmVmMy5lZmZlY3Q7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIHJldHVybiBmbigpO1xuICAgICAgfSk7XG4gICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xufVxuZXhwb3J0IHZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IiwiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldFdpbmRvdy5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07IiwiaW1wb3J0IHsgYXV0byB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFZhcmlhdGlvbihwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xufSIsImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IE1hdGguZmxvb3Iob2Zmc2V0c1ttYWluQXhpc10pIC0gTWF0aC5mbG9vcihyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZW5kOlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IE1hdGguZmxvb3Iob2Zmc2V0c1ttYWluQXhpc10pICsgTWF0aC5jZWlsKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn0iLCJpbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4uL3V0aWxzL2NvbXB1dGVPZmZzZXRzLmpzXCI7XG5cbmZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcbiAgLy8gcHJvcGVybHkgcG9zaXRpb25lZCBuZWFyIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIHN0cmF0ZWd5OiAnYWJzb2x1dGUnLFxuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAncmVhZCcsXG4gIGZuOiBwb3BwZXJPZmZzZXRzLFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIHdpbiA9IHdpbmRvdztcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogTWF0aC5yb3VuZCh4ICogZHByKSAvIGRwciB8fCAwLFxuICAgIHk6IE1hdGgucm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlO1xuXG4gIHZhciBfcm91bmRPZmZzZXRzID0gcm91bmRPZmZzZXRzKG9mZnNldHMpLFxuICAgICAgeCA9IF9yb3VuZE9mZnNldHMueCxcbiAgICAgIHkgPSBfcm91bmRPZmZzZXRzLnk7XG5cbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICB2YXIgc2lkZVggPSBsZWZ0O1xuICB2YXIgc2lkZVkgPSB0b3A7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuXG4gICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcbiAgICAgIG9mZnNldFBhcmVudCA9IGdldERvY3VtZW50RWxlbWVudChwb3BwZXIpO1xuICAgIH0gLy8gJEZsb3dGaXhNZTogZm9yY2UgdHlwZSByZWZpbmVtZW50LCB3ZSBjb21wYXJlIG9mZnNldFBhcmVudCB3aXRoIHdpbmRvdyBhYm92ZSwgYnV0IEZsb3cgZG9lc24ndCBkZXRlY3QgaXRcblxuICAgIC8qOjogb2Zmc2V0UGFyZW50ID0gKG9mZnNldFBhcmVudDogRWxlbWVudCk7ICovXG5cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICB5IC09IG9mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7XG4gICAgICB4IC09IG9mZnNldFBhcmVudC5jbGllbnRXaWR0aCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uXG4gIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8IDIgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduMiA9IHt9LCBfT2JqZWN0JGFzc2lnbjJbc2lkZVldID0gaGFzWSA/IHkgKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVTdHlsZXMoX3JlZjMpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjMuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjMub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZ3B1QWNjZWxlcmF0LFxuICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxuICAgICAgYWRhcHRpdmUgPSBfb3B0aW9ucyRhZGFwdGl2ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGFkYXB0aXZlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gZ2V0Q29tcHV0ZWRTdHlsZShzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCAnJztcblxuICAgIGlmIChhZGFwdGl2ZSAmJiBbJ3RyYW5zZm9ybScsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5zb21lKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25Qcm9wZXJ0eS5pbmRleE9mKHByb3BlcnR5KSA+PSAwO1xuICAgIH0pKSB7XG4gICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZycsICdDU1MgcHJvcGVydGllczogXCJ0cmFuc2Zvcm1cIiwgXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIi4nLCAnXFxuXFxuJywgJ0Rpc2FibGUgdGhlIFwiY29tcHV0ZVN0eWxlc1wiIG1vZGlmaWVyXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsICdmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1MnLCAndHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nJywgJ29wYWNpdHkgb3IgYmFja2dyb3VuZC1jb2xvciBmb3IgZXhhbXBsZS4nLCAnXFxuXFxuJywgJ1dlIHJlY29tbWVuZCB1c2luZyB0aGUgcG9wcGVyIGVsZW1lbnQgYXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBpbm5lcicsICdlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBncHVBY2NlbGVyYXRpb246IGdwdUFjY2VsZXJhdGlvblxuICB9O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCB7fSwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZVxuICAgIH0pKSk7XG4gIH1cblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyAhPSBudWxsKSB7XG4gICAgc3RhdGUuc3R5bGVzLmFycm93ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLmFycm93LCB7fSwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93LFxuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICBhZGFwdGl2ZTogZmFsc2VcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiLCJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBUaGlzIG1vZGlmaWVyIHRha2VzIHRoZSBzdHlsZXMgcHJlcGFyZWQgYnkgdGhlIGBjb21wdXRlU3R5bGVzYCBtb2RpZmllclxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcbiAgdmFyIGluaXRpYWxTdHlsZXMgPSB7XG4gICAgcG9wcGVyOiB7XG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGxlZnQ6ICcwJyxcbiAgICAgIHRvcDogJzAnLFxuICAgICAgbWFyZ2luOiAnMCdcbiAgICB9LFxuICAgIGFycm93OiB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgIH0sXG4gICAgcmVmZXJlbmNlOiB7fVxuICB9O1xuICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xuXG4gIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMuYXJyb3cuc3R5bGUsIGluaXRpYWxTdHlsZXMuYXJyb3cpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcbiAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICAgIHZhciBzdHlsZVByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhzdGF0ZS5zdHlsZXMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBzdGF0ZS5zdHlsZXNbbmFtZV0gOiBpbml0aWFsU3R5bGVzW25hbWVdKTsgLy8gU2V0IGFsbCB2YWx1ZXMgdG8gYW4gZW1wdHkgc3RyaW5nIHRvIHVuc2V0IHRoZW1cblxuICAgICAgdmFyIHN0eWxlID0gc3R5bGVQcm9wZXJ0aWVzLnJlZHVjZShmdW5jdGlvbiAoc3R5bGUsIHByb3BlcnR5KSB7XG4gICAgICAgIHN0eWxlW3Byb3BlcnR5XSA9ICcnO1xuICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICB9LCB7fSk7IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgIWdldE5vZGVOYW1lKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XG4gICAgICAvLyBlZmZlY3RpdmUgd2F5IHRvIGFwcGx5IHN0eWxlcyB0byBhbiBIVE1MRWxlbWVudFxuICAgICAgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBhcHBseVN0eWxlcyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxufTsiLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgcGxhY2VtZW50cyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pKSA6IG9mZnNldCxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcbiAgICB4OiBkaXN0YW5jZSxcbiAgICB5OiBza2lkZGluZ1xuICB9IDoge1xuICAgIHg6IHNraWRkaW5nLFxuICAgIHk6IGRpc3RhbmNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRvZmZzZXQgPSBvcHRpb25zLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICB2YXIgZGF0YSA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCBzdGF0ZS5yZWN0cywgb2Zmc2V0KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHZhciBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQgPSBkYXRhW3N0YXRlLnBsYWNlbWVudF0sXG4gICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdvZmZzZXQnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIGZuOiBvZmZzZXRcbn07IiwidmFyIGhhc2ggPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59IiwidmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufSIsImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IHdpbi5pbm5lcldpZHRoO1xuICB2YXIgaGVpZ2h0ID0gd2luLmlubmVySGVpZ2h0OyAvLyBXZSBkb24ndCBrbm93IHdoaWNoIGJyb3dzZXJzIGhhdmUgYnVnZ3kgb3Igb2RkIGltcGxlbWVudGF0aW9ucyBvZiB0aGlzLCBzb1xuICAvLyBmb3Igbm93IHdlJ3JlIG9ubHkgYXBwbHlpbmcgaXQgdG8gaU9TIHRvIGZpeCB0aGUga2V5Ym9hcmQgaXNzdWUuXG4gIC8vIEludmVzdGlnYXRpb24gcmVxdWlyZWRcblxuICBpZiAodmlzdWFsVmlld3BvcnQgJiYgL2lQaG9uZXxpUG9kfGlQYWQvLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKSkge1xuICAgIHdpZHRoID0gdmlzdWFsVmlld3BvcnQud2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG59IiwiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZ2V0Q29tcG9zaXRlUmVjdC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgdmFyIGRvY3VtZW50UmVjdCA9IGdldENvbXBvc2l0ZVJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpLCB3aW4pO1xuICBkb2N1bWVudFJlY3QuaGVpZ2h0ID0gTWF0aC5tYXgoZG9jdW1lbnRSZWN0LmhlaWdodCwgd2luLmlubmVySGVpZ2h0KTtcbiAgZG9jdW1lbnRSZWN0LndpZHRoID0gTWF0aC5tYXgoZG9jdW1lbnRSZWN0LndpZHRoLCB3aW4uaW5uZXJXaWR0aCk7XG4gIGRvY3VtZW50UmVjdC54ID0gLXdpblNjcm9sbC5zY3JvbGxMZWZ0O1xuICBkb2N1bWVudFJlY3QueSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xuICByZXR1cm4gZG9jdW1lbnRSZWN0O1xufSIsImltcG9ydCBnZXRDb21wdXRlZFN0eWxlIGZyb20gXCIuL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCB7IGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5cbmZ1bmN0aW9uIHRvTnVtYmVyKGNzc1ZhbHVlKSB7XG4gIHJldHVybiBwYXJzZUZsb2F0KGNzc1ZhbHVlKSB8fCAwO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCb3JkZXJzKGVsZW1lbnQpIHtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSA6IHt9O1xuICByZXR1cm4ge1xuICAgIHRvcDogdG9OdW1iZXIoY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BXaWR0aCksXG4gICAgcmlnaHQ6IHRvTnVtYmVyKGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCksXG4gICAgYm90dG9tOiB0b051bWJlcihjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoKSxcbiAgICBsZWZ0OiB0b051bWJlcihjb21wdXRlZFN0eWxlLmJvcmRlckxlZnRXaWR0aClcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0Qm9yZGVycyBmcm9tIFwiLi9nZXRCb3JkZXJzLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7IC8vIEJvcmRlcnMgKyBzY3JvbGxiYXJzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERlY29yYXRpb25zKGVsZW1lbnQpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGJvcmRlcnMgPSBnZXRCb3JkZXJzKGVsZW1lbnQpO1xuICB2YXIgaXNIVE1MID0gZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJztcbiAgdmFyIHdpblNjcm9sbEJhclggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICB2YXIgeCA9IGVsZW1lbnQuY2xpZW50V2lkdGggKyBib3JkZXJzLnJpZ2h0O1xuICB2YXIgeSA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0ICsgYm9yZGVycy5ib3R0b207IC8vIEhBQ0s6XG4gIC8vIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQgb24gaU9TIHJlcG9ydHMgdGhlIGhlaWdodCBvZiB0aGVcbiAgLy8gdmlld3BvcnQgaW5jbHVkaW5nIHRoZSBib3R0b20gYmFyLCBldmVuIGlmIHRoZSBib3R0b20gYmFyIGlzbid0IHZpc2libGUuXG4gIC8vIElmIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gd2luZG93IGlubmVySGVpZ2h0IGFuZCBodG1sIGNsaWVudEhlaWdodCBpcyBtb3JlXG4gIC8vIHRoYW4gNTAsIHdlIGFzc3VtZSBpdCdzIGEgbW9iaWxlIGJvdHRvbSBiYXIgYW5kIGlnbm9yZSBzY3JvbGxiYXJzLlxuICAvLyAqIEEgNTBweCB0aGljayBzY3JvbGxiYXIgaXMgbGlrZWx5IG5vbi1leGlzdGVudCAobWFjT1MgaXMgMTVweCBhbmQgV2luZG93c1xuICAvLyAgIGlzIGFib3V0IDE3cHgpXG4gIC8vICogVGhlIG1vYmlsZSBiYXIgaXMgMTE0cHggdGFsbFxuXG4gIGlmIChpc0hUTUwgJiYgd2luLmlubmVySGVpZ2h0IC0gZWxlbWVudC5jbGllbnRIZWlnaHQgPiA1MCkge1xuICAgIHkgPSB3aW4uaW5uZXJIZWlnaHQgLSBib3JkZXJzLmJvdHRvbTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBpc0hUTUwgPyAwIDogZWxlbWVudC5jbGllbnRUb3AsXG4gICAgcmlnaHQ6IC8vIFJUTCBzY3JvbGxiYXIgKHNjcm9sbGluZyBjb250YWluZXJzIG9ubHkpXG4gICAgZWxlbWVudC5jbGllbnRMZWZ0ID4gYm9yZGVycy5sZWZ0ID8gYm9yZGVycy5yaWdodCA6IC8vIExUUiBzY3JvbGxiYXJcbiAgICBpc0hUTUwgPyB3aW4uaW5uZXJXaWR0aCAtIHggLSB3aW5TY3JvbGxCYXJYIDogZWxlbWVudC5vZmZzZXRXaWR0aCAtIHgsXG4gICAgYm90dG9tOiBpc0hUTUwgPyB3aW4uaW5uZXJIZWlnaHQgLSB5IDogZWxlbWVudC5vZmZzZXRIZWlnaHQgLSB5LFxuICAgIGxlZnQ6IGlzSFRNTCA/IHdpblNjcm9sbEJhclggOiBlbGVtZW50LmNsaWVudExlZnRcbiAgfTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gIC8vICRGbG93Rml4TWU6IGhhc093blByb3BlcnR5IGRvZXNuJ3Qgc2VlbSB0byB3b3JrIGluIHRlc3RzXG4gIHZhciBpc1NoYWRvdyA9IEJvb2xlYW4oY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKS5ob3N0KTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgZWxzZSBpZiAoaXNTaGFkb3cpIHtcbiAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKG5leHQgJiYgcGFyZW50LmlzU2FtZU5vZGUobmV4dCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn0iLCJpbXBvcnQgeyB2aWV3cG9ydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldFZpZXdwb3J0UmVjdCBmcm9tIFwiLi9nZXRWaWV3cG9ydFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudFJlY3QgZnJvbSBcIi4vZ2V0RG9jdW1lbnRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vbGlzdFNjcm9sbFBhcmVudHMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4vZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXREZWNvcmF0aW9ucyBmcm9tIFwiLi9nZXREZWNvcmF0aW9ucy5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgcmVjdFRvQ2xpZW50UmVjdCBmcm9tIFwiLi4vdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuXG5mdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCkpIDogaXNIVE1MRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoY2xpcHBpbmdQYXJlbnQpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50KTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5KSB7XG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50KTtcbiAgICB2YXIgZGVjb3JhdGlvbnMgPSBnZXREZWNvcmF0aW9ucyhpc0hUTUxFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGNsaXBwaW5nUGFyZW50IDogZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKTtcbiAgICBhY2NSZWN0LnRvcCA9IE1hdGgubWF4KHJlY3QudG9wICsgZGVjb3JhdGlvbnMudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IE1hdGgubWluKHJlY3QucmlnaHQgLSBkZWNvcmF0aW9ucy5yaWdodCwgYWNjUmVjdC5yaWdodCk7XG4gICAgYWNjUmVjdC5ib3R0b20gPSBNYXRoLm1pbihyZWN0LmJvdHRvbSAtIGRlY29yYXRpb25zLmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IE1hdGgubWF4KHJlY3QubGVmdCArIGRlY29yYXRpb25zLmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQpKTtcbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn0iLCJpbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuL2dldEZyZXNoU2lkZU9iamVjdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCB7fSwgcGFkZGluZ09iamVjdCk7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iLCJpbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0Q2xpcHBpbmdSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0Q2xpcHBpbmdSZWN0LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgY29tcHV0ZU9mZnNldHMgZnJvbSBcIi4vY29tcHV0ZU9mZnNldHMuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuL3JlY3RUb0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCB7IGNsaXBwaW5nUGFyZW50cywgcmVmZXJlbmNlLCBwb3BwZXIsIGJvdHRvbSwgdG9wLCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQgfSBmcm9tIFwiLi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4vbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuL2V4cGFuZFRvSGFzaE1hcC5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxuICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMkcGxhY2VtZW50ID09PSB2b2lkIDAgPyBzdGF0ZS5wbGFjZW1lbnQgOiBfb3B0aW9ucyRwbGFjZW1lbnQsXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciByZWZlcmVuY2VFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnkpO1xuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2VFbGVtZW50KTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCB7fSwgcG9wcGVyT2Zmc2V0cykpO1xuICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgLy8gMCBvciBuZWdhdGl2ZSA9IHdpdGhpbiB0aGUgY2xpcHBpbmcgcmVjdFxuXG4gIHZhciBvdmVyZmxvd09mZnNldHMgPSB7XG4gICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXG4gICAgbGVmdDogY2xpcHBpbmdDbGllbnRSZWN0LmxlZnQgLSBlbGVtZW50Q2xpZW50UmVjdC5sZWZ0ICsgcGFkZGluZ09iamVjdC5sZWZ0LFxuICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgfTtcbiAgdmFyIG9mZnNldERhdGEgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDsgLy8gT2Zmc2V0cyBjYW4gYmUgYXBwbGllZCBvbmx5IHRvIHRoZSBwb3BwZXIgZWxlbWVudFxuXG4gIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICB2YXIgb2Zmc2V0ID0gb2Zmc2V0RGF0YVtwbGFjZW1lbnRdO1xuICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICB2YXIgYXhpcyA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAneScgOiAneCc7XG4gICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBvdmVyZmxvd09mZnNldHM7XG59IiwiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuXG4vKjo6IHR5cGUgT3ZlcmZsb3dzTWFwID0geyBbQ29tcHV0ZWRQbGFjZW1lbnRdOiBudW1iZXIgfTsgKi9cblxuLyo7OyB0eXBlIE92ZXJmbG93c01hcCA9IHsgW2tleSBpbiBDb21wdXRlZFBsYWNlbWVudF06IG51bWJlciB9OyAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gKHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cykuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xuICB9KTsgLy8gJEZsb3dGaXhNZTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG4gIHZhciBvdmVyZmxvd3MgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59IiwiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59OyIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgcmV0dXJuIE1hdGgubWF4KG1pbiwgTWF0aC5taW4odmFsdWUsIG1heCkpO1xufSIsImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgc3RhcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRBbHRBeGlzIGZyb20gXCIuLi91dGlscy9nZXRBbHRBeGlzLmpzXCI7XG5pbXBvcnQgd2l0aGluIGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGRldGVjdE92ZXJmbG93IGZyb20gXCIuLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi4vdXRpbHMvZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0RnJlc2hTaWRlT2JqZWN0IGZyb20gXCIuLi91dGlscy9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBkYXRhID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuXG4gIGlmICghcG9wcGVyT2Zmc2V0cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4gPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc10gLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIHRldGhlck9mZnNldFZhbHVlIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSB0ZXRoZXJPZmZzZXRWYWx1ZTtcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgdGV0aGVyT2Zmc2V0VmFsdWUgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIHRldGhlck9mZnNldFZhbHVlO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93ICYmIGdldE9mZnNldFBhcmVudChzdGF0ZS5lbGVtZW50cy5hcnJvdyk7XG4gICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0ID8gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXRbc3RhdGUucGxhY2VtZW50XVttYWluQXhpc10gOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSArIG1pbk9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWUgLSBjbGllbnRPZmZzZXQ7XG4gICAgdmFyIHRldGhlck1heCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IE1hdGgubWluKG1pbiwgdGV0aGVyTWluKSA6IG1pbiwgb2Zmc2V0LCB0ZXRoZXIgPyBNYXRoLm1heChtYXgsIHRldGhlck1heCkgOiBtYXgpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIHZhciBfbWluID0gX29mZnNldCArIG92ZXJmbG93W19tYWluU2lkZV07XG5cbiAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XG5cbiAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHdpdGhpbihfbWluLCBfb2Zmc2V0LCBfbWF4KTtcblxuICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0IC0gX29mZnNldDtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgZm46IHByZXZlbnRPdmVyZmxvdyxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXVxufTsiLCJpbXBvcnQgZ2V0QmFzZVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldExheW91dFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgY29udGFpbnMgZnJvbSBcIi4uL2RvbS11dGlscy9jb250YWlucy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgd2l0aGluIGZyb20gXCIuLi91dGlscy93aXRoaW4uanNcIjtcbmltcG9ydCBtZXJnZVBhZGRpbmdPYmplY3QgZnJvbSBcIi4uL3V0aWxzL21lcmdlUGFkZGluZ09iamVjdC5qc1wiO1xuaW1wb3J0IGV4cGFuZFRvSGFzaE1hcCBmcm9tIFwiLi4vdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzXCI7XG5pbXBvcnQgeyBsZWZ0LCByaWdodCwgYmFzZVBsYWNlbWVudHMsIHRvcCwgYm90dG9tIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4uL2RvbS11dGlscy9pbnN0YW5jZU9mLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZnVuY3Rpb24gYXJyb3coX3JlZikge1xuICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWUgKyBcIiNwZXJzaXN0ZW50XCJdLnBhZGRpbmc7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcblxuICBpZiAoYXJyb3dFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gQ1NTIHNlbGVjdG9yXG5cblxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBlbGVtZW50IG11c3QgYmUgYW4gSFRNTEVsZW1lbnQgKG5vdCBhbiBTVkdFbGVtZW50KS4nLCAnVG8gdXNlIGFuIFNWRyBhcnJvdywgd3JhcCBpdCBpbiBhbiBIVE1MRWxlbWVudCB0aGF0IHdpbGwgYmUgdXNlZCBhcycsICd0aGUgYXJyb3cuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbnRhaW5zKHN0YXRlLmVsZW1lbnRzLnBvcHBlciwgYXJyb3dFbGVtZW50KSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoWydQb3BwZXI6IFwiYXJyb3dcIiBtb2RpZmllclxcJ3MgYGVsZW1lbnRgIG11c3QgYmUgYSBjaGlsZCBvZiB0aGUgcG9wcGVyJywgJ2VsZW1lbnQuJ10uam9pbignICcpKTtcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lICsgXCIjcGVyc2lzdGVudFwiXSA9IHtcbiAgICBwYWRkaW5nOiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpXG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiLCJpbXBvcnQgeyB0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcblxuZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcbiAgaWYgKHByZXZlbnRlZE9mZnNldHMgPT09IHZvaWQgMCkge1xuICAgIHByZXZlbnRlZE9mZnNldHMgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHRvcDogb3ZlcmZsb3cudG9wIC0gcmVjdC5oZWlnaHQgLSBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICBib3R0b206IG92ZXJmbG93LmJvdHRvbSAtIHJlY3QuaGVpZ2h0ICsgcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIGxlZnQ6IG92ZXJmbG93LmxlZnQgLSByZWN0LndpZHRoIC0gcHJldmVudGVkT2Zmc2V0cy54XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChvdmVyZmxvdykge1xuICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0uc29tZShmdW5jdGlvbiAoc2lkZSkge1xuICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gaGlkZShfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XG4gIHZhciByZWZlcmVuY2VPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXG4gIH0pO1xuICB2YXIgcG9wcGVyQWx0T3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGFsdEJvdW5kYXJ5OiB0cnVlXG4gIH0pO1xuICB2YXIgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocmVmZXJlbmNlT3ZlcmZsb3csIHJlZmVyZW5jZVJlY3QpO1xuICB2YXIgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHBvcHBlckFsdE92ZXJmbG93LCBwb3BwZXJSZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKTtcbiAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gIHZhciBoYXNQb3BwZXJFc2NhcGVkID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHBvcHBlckVzY2FwZU9mZnNldHMpO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0ge1xuICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxuICAgIHBvcHBlckVzY2FwZU9mZnNldHM6IHBvcHBlckVzY2FwZU9mZnNldHMsXG4gICAgaXNSZWZlcmVuY2VIaWRkZW46IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcbiAgfTtcbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgJ2RhdGEtcG9wcGVyLWVzY2FwZWQnOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH0pO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnaGlkZScsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG4gIGZuOiBoaWRlXG59OyIsImltcG9ydCB7IHBvcHBlckdlbmVyYXRvciB9IGZyb20gXCIuL2luZGV4LmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMsIGNvbXB1dGVTdHlsZXMsIGFwcGx5U3R5bGVzLCBvZmZzZXQsIGZsaXAsIHByZXZlbnRPdmVyZmxvdywgYXJyb3csIGhpZGVdO1xudmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXG59KTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5leHBvcnQgeyBjcmVhdGVQb3BwZXIsIHBvcHBlckdlbmVyYXRvciwgZGVmYXVsdE1vZGlmaWVycywgZGV0ZWN0T3ZlcmZsb3cgfTsiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQStCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUlBO0FBQ0E7QUFDQTtBQUNBLGlCQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///29\n")}]);